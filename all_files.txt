=== FILE: ./sepolia_patch.sh ===
#!/bin/bash

# Patch script to optimize deploy.js for Sepolia deployment with limited ETH

echo "================================================"
echo " Patching deploy.js for Sepolia Deployment"
echo "================================================"
echo ""

# Backup original deploy.js
cp scripts/deploy.js scripts/deploy.js.backup

# Create optimized deploy.js for Sepolia
cat > scripts/deploy.js << 'EOF'
// deploy.js - Deployment script optimized for Sepolia with limited ETH
const { ethers } = require("hardhat");
const fs = require('fs');

async function main() {
  console.log("ðŸš€ Deploying ERC-4337 & ERC-6900 Smart Account System to", network.name, "...\n");

  // Get deployer
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with account:", deployer.address);
  const balance = await deployer.getBalance();
  console.log("Account balance:", ethers.utils.formatEther(balance), "ETH");
  
  // Check if we have enough ETH
  if (network.name === "sepolia" && balance.lt(ethers.utils.parseEther("0.05"))) {
    console.log("\nâš ï¸  Warning: Low balance for Sepolia deployment!");
    console.log("Recommended: At least 0.05 ETH for safe deployment");
    console.log("Current: ", ethers.utils.formatEther(balance), "ETH\n");
  }

  // Deploy EntryPoint (or use existing one)
  console.log("1. Checking EntryPoint...");
  let entryPoint;
  if (network.name === "localhost" || network.name === "hardhat") {
    console.log("   Deploying MockEntryPoint for local testing...");
    const MockEntryPoint = await ethers.getContractFactory("MockEntryPoint");
    entryPoint = await MockEntryPoint.deploy();
    await entryPoint.deployed();
    console.log("   âœ“ MockEntryPoint deployed to:", entryPoint.address);
  } else {
    // Use the official EntryPoint address for testnets/mainnet
    entryPoint = { address: "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789" };
    console.log("   âœ“ Using official EntryPoint at:", entryPoint.address);
    console.log("   (No deployment needed - saves gas!)");
  }

  // Deploy MultiSigPlugin with gas optimization
  console.log("\n2. Deploying MultiSigPlugin...");
  const MultiSigPlugin = await ethers.getContractFactory("MultiSigPlugin");
  
  // Estimate gas and add buffer
  const deployTx = MultiSigPlugin.getDeployTransaction();
  const estimatedGas = await deployer.estimateGas(deployTx);
  console.log("   Estimated gas:", estimatedGas.toString());
  
  // Deploy with optimized gas settings for Sepolia
  const multiSigPlugin = await MultiSigPlugin.deploy({
    gasLimit: estimatedGas.mul(110).div(100), // 10% buffer
    maxFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("20", "gwei") : undefined,
    maxPriorityFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("1.5", "gwei") : undefined
  });
  
  await multiSigPlugin.deployed();
  console.log("   âœ“ MultiSigPlugin deployed to:", multiSigPlugin.address);
  console.log("   Gas used:", (await multiSigPlugin.deployTransaction.wait()).gasUsed.toString());

  // Deploy SmartAccountFactory with gas optimization
  console.log("\n3. Deploying SmartAccountFactory...");
  const SmartAccountFactory = await ethers.getContractFactory("SmartAccountFactory");
  
  // Deploy with optimized gas settings
  const factory = await SmartAccountFactory.deploy(entryPoint.address, {
    gasLimit: 3000000, // Fixed reasonable limit
    maxFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("20", "gwei") : undefined,
    maxPriorityFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("1.5", "gwei") : undefined
  });
  
  await factory.deployed();
  console.log("   âœ“ SmartAccountFactory deployed to:", factory.address);
  console.log("   Gas used:", (await factory.deployTransaction.wait()).gasUsed.toString());

  // Calculate total deployment cost
  if (network.name === "sepolia") {
    const deployerEndBalance = await deployer.getBalance();
    const totalCost = balance.sub(deployerEndBalance);
    console.log("\nðŸ’° Deployment Cost Summary:");
    console.log("   Total ETH spent:", ethers.utils.formatEther(totalCost));
    console.log("   Remaining balance:", ethers.utils.formatEther(deployerEndBalance), "ETH");
  }

  // Save deployment addresses
  const deploymentInfo = {
    network: network.name,
    chainId: network.config.chainId,
    deployer: deployer.address,
    contracts: {
      entryPoint: entryPoint.address,
      multiSigPlugin: multiSigPlugin.address,
      factory: factory.address
    },
    timestamp: new Date().toISOString(),
    deploymentCost: network.name === "sepolia" ? {
      multiSigPluginGas: (await multiSigPlugin.deployTransaction.wait()).gasUsed.toString(),
      factoryGas: (await factory.deployTransaction.wait()).gasUsed.toString()
    } : undefined
  };

  // Write deployment info to file
  fs.writeFileSync(
    `deployments-${network.name}.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );

  // Update addresses.json
  const addressesPath = './scripts/addresses.json';
  let addresses = {};
  if (fs.existsSync(addressesPath)) {
    addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
  }
  
  addresses[network.name] = {
    entryPoint: entryPoint.address,
    factory: factory.address,
    multiSigPlugin: multiSigPlugin.address
  };
  
  fs.writeFileSync(addressesPath, JSON.stringify(addresses, null, 2));

  console.log("\nâœ… Deployment complete!");
  console.log("\nðŸ“„ Deployment info saved to:", `deployments-${network.name}.json`);
  console.log("\nðŸ”— Contract Addresses:");
  console.log("   EntryPoint:", entryPoint.address);
  console.log("   MultiSigPlugin:", multiSigPlugin.address);
  console.log("   SmartAccountFactory:", factory.address);
  
  // Sepolia specific instructions
  if (network.name === "sepolia") {
    console.log("\nðŸ“ Next Steps for Sepolia:");
    console.log("   1. Verify contracts on Etherscan:");
    console.log("      npx hardhat run scripts/verify.js --network sepolia");
    console.log("   2. Update frontend with deployed addresses");
    console.log("   3. You can interact with contracts at:");
    console.log("      https://sepolia.etherscan.io/address/" + multiSigPlugin.address);
    console.log("      https://sepolia.etherscan.io/address/" + factory.address);
  }
  
  // Skip automatic verification for Sepolia to save time
  if (network.name === "sepolia") {
    console.log("\nðŸ“Œ Note: Skipping automatic verification to complete deployment faster.");
    console.log("   Run verification manually when ready.");
  } else if (network.name !== "localhost" && network.name !== "hardhat") {
    console.log("\nðŸ” Waiting before verification...");
    await new Promise(resolve => setTimeout(resolve, 20000));
    
    try {
      await hre.run("verify:verify", {
        address: multiSigPlugin.address,
        constructorArguments: [],
      });
      
      await hre.run("verify:verify", {
        address: factory.address,
        constructorArguments: [entryPoint.address],
      });
      
      console.log("âœ… Contracts verified!");
    } catch (error) {
      console.log("âš ï¸  Verification failed:", error.message);
    }
  }

  return deploymentInfo;
}

// Minimal test script for Sepolia (to save gas)
async function minimalTest(deploymentInfo) {
  console.log("\nðŸ§ª Running minimal deployment test...\n");
  
  const [deployer] = await ethers.getSigners();
  
  // Just verify contracts are deployed
  console.log("1. Checking MultiSigPlugin...");
  const multiSigCode = await ethers.provider.getCode(deploymentInfo.contracts.multiSigPlugin);
  console.log("   âœ“ MultiSigPlugin deployed:", multiSigCode.length > 2);
  
  console.log("\n2. Checking SmartAccountFactory...");
  const factoryCode = await ethers.provider.getCode(deploymentInfo.contracts.factory);
  console.log("   âœ“ SmartAccountFactory deployed:", factoryCode.length > 2);
  
  console.log("\nâœ… Basic deployment verification passed!");
  console.log("\nðŸ’¡ Tip: Create and test smart accounts using the frontend to save ETH");
}

// Run deployment
main()
  .then(async (deploymentInfo) => {
    // Only run tests on localhost
    if (network.name === "localhost" && process.env.RUN_TESTS === "true") {
      const { testDeployment } = require('./test-deployment');
      await testDeployment(deploymentInfo);
    } else if (network.name === "sepolia") {
      await minimalTest(deploymentInfo);
    }
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nâŒ Deployment failed:", error.message);
    console.error(error);
    process.exit(1);
  });
EOF

# Create a quick deployment script specifically for Sepolia
cat > scripts/deploy-sepolia.sh << 'EOF'
#!/bin/bash

echo "======================================"
echo " Deploying to Sepolia Testnet"
echo "======================================"
echo ""

# Check if .env exists
if [ ! -f .env ]; then
    echo "âŒ Error: .env file not found!"
    echo "Please copy .env.example to .env and add your keys"
    exit 1
fi

# Load environment variables
source .env

# Check if PRIVATE_KEY is set
if [ -z "$PRIVATE_KEY" ]; then
    echo "âŒ Error: PRIVATE_KEY not set in .env!"
    exit 1
fi

# Check if SEPOLIA_RPC_URL is set
if [ -z "$SEPOLIA_RPC_URL" ]; then
    echo "âŒ Error: SEPOLIA_RPC_URL not set in .env!"
    exit 1
fi

echo "âœ“ Environment configured"
echo ""

# Compile contracts
echo "ðŸ“¦ Compiling contracts..."
npx hardhat compile

if [ $? -ne 0 ]; then
    echo "âŒ Compilation failed!"
    exit 1
fi

echo "âœ“ Contracts compiled"
echo ""

# Deploy to Sepolia
echo "ðŸš€ Deploying to Sepolia..."
echo "This will use approximately 0.02-0.05 ETH"
echo ""

npx hardhat run scripts/deploy.js --network sepolia

if [ $? -eq 0 ]; then
    echo ""
    echo "âœ… Deployment successful!"
    echo ""
    echo "ðŸ“‹ Check deployments-sepolia.json for contract addresses"
    echo ""
    echo "Next steps:"
    echo "1. Verify contracts: npx hardhat run scripts/verify.js --network sepolia"
    echo "2. Update frontend with the deployed addresses"
    echo "3. Test using the React GUI"
else
    echo ""
    echo "âŒ Deployment failed!"
    echo "Check your ETH balance and try again"
fi
EOF

# Make the script executable
chmod +x scripts/deploy-sepolia.sh

# Create a gas estimation script
cat > scripts/estimate-gas.js << 'EOF'
// estimate-gas.js - Estimate deployment costs
const { ethers } = require("hardhat");

async function main() {
  console.log("ðŸ’° Estimating deployment costs for", network.name, "...\n");
  
  const [deployer] = await ethers.getSigners();
  
  // Get current gas prices
  const gasPrice = await deployer.getGasPrice();
  console.log("Current gas price:", ethers.utils.formatUnits(gasPrice, "gwei"), "gwei");
  
  // Estimate MockEntryPoint (only for localhost)
  if (network.name === "localhost") {
    const MockEntryPoint = await ethers.getContractFactory("MockEntryPoint");
    const mockGas = await deployer.estimateGas(MockEntryPoint.getDeployTransaction());
    console.log("\nMockEntryPoint:");
    console.log("  Gas:", mockGas.toString());
    console.log("  Cost:", ethers.utils.formatEther(mockGas.mul(gasPrice)), "ETH");
  }
  
  // Estimate MultiSigPlugin
  const MultiSigPlugin = await ethers.getContractFactory("MultiSigPlugin");
  const multiSigGas = await deployer.estimateGas(MultiSigPlugin.getDeployTransaction());
  console.log("\nMultiSigPlugin:");
  console.log("  Gas:", multiSigGas.toString());
  console.log("  Cost:", ethers.utils.formatEther(multiSigGas.mul(gasPrice)), "ETH");
  
  // Estimate SmartAccountFactory
  const SmartAccountFactory = await ethers.getContractFactory("SmartAccountFactory");
  const factoryGas = await deployer.estimateGas(
    SmartAccountFactory.getDeployTransaction("0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789")
  );
  console.log("\nSmartAccountFactory:");
  console.log("  Gas:", factoryGas.toString());
  console.log("  Cost:", ethers.utils.formatEther(factoryGas.mul(gasPrice)), "ETH");
  
  // Total
  const totalGas = multiSigGas.add(factoryGas);
  const totalCost = totalGas.mul(gasPrice);
  console.log("\nðŸ“Š Total Deployment Cost:");
  console.log("  Total Gas:", totalGas.toString());
  console.log("  Total Cost:", ethers.utils.formatEther(totalCost), "ETH");
  
  // With 50% buffer
  const bufferedCost = totalCost.mul(150).div(100);
  console.log("  With 50% buffer:", ethers.utils.formatEther(bufferedCost), "ETH");
  
  if (network.name === "sepolia") {
    console.log("\nðŸ’¡ Sepolia Deployment Tips:");
    console.log("  - Current balance needed: ~", ethers.utils.formatEther(bufferedCost), "ETH");
    console.log("  - Your 0.1 ETH should be sufficient!");
    console.log("  - Use the deploy-sepolia.sh script for easy deployment");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
EOF

echo ""
echo "================================================"
echo "[+] Sepolia deployment patch applied!"
echo "================================================"
echo ""
echo "ðŸ“‹ What was updated:"
echo "  - Optimized gas settings for Sepolia"
echo "  - Added deployment cost tracking"
echo "  - Skip automatic verification (do it manually)"
echo "  - Created deploy-sepolia.sh for easy deployment"
echo "  - Added gas estimation script"
echo ""
echo "ðŸš€ To deploy to Sepolia:"
echo ""
echo "1. Make sure your .env file has:"
echo "   PRIVATE_KEY=your_private_key_here"
echo "   SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY"
echo ""
echo "2. Estimate gas costs:"
echo "   npx hardhat run scripts/estimate-gas.js --network sepolia"
echo ""
echo "3. Deploy:"
echo "   ./scripts/deploy-sepolia.sh"
echo ""
echo "   OR manually:"
echo "   npx hardhat run scripts/deploy.js --network sepolia"
echo ""
echo "ðŸ’¡ Your 0.1 SepoliaETH should be more than enough!"
echo "   Expected cost: ~0.02-0.05 ETH"


=== FILE: ./frontend/public/index.html ===
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="ERC-4337 & ERC-6900 Multi-Sig Wallet" />
  <title>Smart Account Multi-Sig</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
</body>
</html>



=== FILE: ./frontend/package.json ===
{
  "name": "erc4337-multisig-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "lucide-react": "^0.263.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
  }
}



=== FILE: ./frontend/src/index.js ===
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



=== FILE: ./frontend/src/utils/.gitkeep ===
# Place wallet.js here



=== FILE: ./frontend/src/utils/wallet.js ===
// wallet.js - ERC-4337 Smart Account Wallet Implementation
import { ethers } from 'ethers';

class SmartAccountWallet {
    constructor(provider, entryPointAddress, factoryAddress, multiSigPluginAddress) {
        this.provider = provider;
        this.entryPointAddress = entryPointAddress;
        this.factoryAddress = factoryAddress;
        this.multiSigPluginAddress = multiSigPluginAddress;
        this.signer = null;
        this.accountAddress = null;
    }

    // Initialize wallet with a signer
    async init(privateKey) {
        this.signer = new ethers.Wallet(privateKey, this.provider);
        return this.signer.address;
    }

    // Create a new smart account
    async createAccount(salt = 0) {
        const factory = new ethers.Contract(
            this.factoryAddress,
            [
                'function createAccount(address owner, uint256 salt) returns (address)',
                'function getAddress(address owner, uint256 salt) view returns (address)'
            ],
            this.signer
        );

        // Get predicted address
        this.accountAddress = await factory.getAddress(this.signer.address, salt);
        
        // Check if already deployed
        const code = await this.provider.getCode(this.accountAddress);
        if (code === '0x') {
            // Deploy the account
            const tx = await factory.createAccount(this.signer.address, salt);
            await tx.wait();
        }

        return this.accountAddress;
    }

    // Install multi-sig plugin
    async installMultiSigPlugin(owners, threshold) {
        const account = new ethers.Contract(
            this.accountAddress,
            [
                'function installPlugin(bytes4 selector, address plugin, bytes data)'
            ],
            this.signer
        );

        // Selector for multi-sig validation
        const selector = '0x00000000'; // Custom selector for multi-sig operations
        
        // Encode installation data
        const installData = ethers.utils.defaultAbiCoder.encode(
            ['address[]', 'uint256'],
            [owners, threshold]
        );

        const userOp = await this.createUserOperation(
            account.interface.encodeFunctionData('installPlugin', [
                selector,
                this.multiSigPluginAddress,
                installData
            ])
        );

        return await this.sendUserOperation(userOp);
    }

    // Create a UserOperation
    async createUserOperation(callData, options = {}) {
        const account = new ethers.Contract(
            this.accountAddress,
            ['function nonce() view returns (uint256)'],
            this.provider
        );

        const nonce = await account.nonce();
        
        const userOp = {
            sender: this.accountAddress,
            nonce: nonce,
            initCode: '0x',
            callData: callData,
            callGasLimit: options.callGasLimit || 200000,
            verificationGasLimit: options.verificationGasLimit || 100000,
            preVerificationGas: options.preVerificationGas || 50000,
            maxFeePerGas: options.maxFeePerGas || ethers.utils.parseUnits('30', 'gwei'),
            maxPriorityFeePerGas: options.maxPriorityFeePerGas || ethers.utils.parseUnits('2', 'gwei'),
            paymasterAndData: '0x',
            signature: '0x'
        };

        // Sign the operation
        userOp.signature = await this.signUserOperation(userOp);

        return userOp;
    }

    // Sign a UserOperation
    async signUserOperation(userOp) {
        const userOpHash = this.getUserOpHash(userOp);
        const signature = await this.signer.signMessage(ethers.utils.arrayify(userOpHash));
        return signature;
    }

    // Calculate UserOperation hash
    getUserOpHash(userOp) {
        const packed = ethers.utils.defaultAbiCoder.encode(
            [
                'address',
                'uint256',
                'bytes32',
                'bytes32',
                'uint256',
                'uint256',
                'uint256',
                'uint256',
                'uint256',
                'bytes32'
            ],
            [
                userOp.sender,
                userOp.nonce,
                ethers.utils.keccak256(userOp.initCode),
                ethers.utils.keccak256(userOp.callData),
                userOp.callGasLimit,
                userOp.verificationGasLimit,
                userOp.preVerificationGas,
                userOp.maxFeePerGas,
                userOp.maxPriorityFeePerGas,
                ethers.utils.keccak256(userOp.paymasterAndData)
            ]
        );

        const encoded = ethers.utils.defaultAbiCoder.encode(
            ['bytes32', 'address', 'uint256'],
            [ethers.utils.keccak256(packed), this.entryPointAddress, this.provider.network.chainId]
        );

        return ethers.utils.keccak256(encoded);
    }

    // Send UserOperation to the EntryPoint
    async sendUserOperation(userOp) {
        const entryPoint = new ethers.Contract(
            this.entryPointAddress,
            [
                'function handleOps(tuple(address sender, uint256 nonce, bytes initCode, bytes callData, uint256 callGasLimit, uint256 verificationGasLimit, uint256 preVerificationGas, uint256 maxFeePerGas, uint256 maxPriorityFeePerGas, bytes paymasterAndData, bytes signature)[] ops, address beneficiary)'
            ],
            this.signer
        );

        const tx = await entryPoint.handleOps([userOp], this.signer.address);
        return await tx.wait();
    }

    // Execute a transaction through the smart account
    async execute(to, value, data) {
        const account = new ethers.Contract(
            this.accountAddress,
            ['function execute(address to, uint256 value, bytes data)'],
            this.provider
        );

        const callData = account.interface.encodeFunctionData('execute', [to, value, data]);
        const userOp = await this.createUserOperation(callData);

        return await this.sendUserOperation(userOp);
    }

    // Execute batch transactions
    async executeBatch(targets, values, datas) {
        const account = new ethers.Contract(
            this.accountAddress,
            ['function executeBatch(address[] to, uint256[] value, bytes[] data)'],
            this.provider
        );

        const callData = account.interface.encodeFunctionData('executeBatch', [targets, values, datas]);
        const userOp = await this.createUserOperation(callData);

        return await this.sendUserOperation(userOp);
    }

    // Submit a multi-sig transaction
    async submitMultiSigTransaction(to, value, data) {
        const multiSig = new ethers.Contract(
            this.multiSigPluginAddress,
            [
                'function submitTransaction(address to, uint256 value, bytes data) returns (uint256)'
            ],
            this.signer
        );

        const callData = multiSig.interface.encodeFunctionData('submitTransaction', [to, value, data]);
        
        // Execute through the smart account
        return await this.execute(this.multiSigPluginAddress, 0, callData);
    }

    // Confirm a multi-sig transaction
    async confirmMultiSigTransaction(txId) {
        const multiSig = new ethers.Contract(
            this.multiSigPluginAddress,
            ['function confirmTransaction(uint256 txId)'],
            this.signer
        );

        const callData = multiSig.interface.encodeFunctionData('confirmTransaction', [txId]);
        
        // Execute through the smart account
        return await this.execute(this.multiSigPluginAddress, 0, callData);
    }

    // Get account balance
    async getBalance() {
        return await this.provider.getBalance(this.accountAddress);
    }

    // Deposit to EntryPoint
    async depositToEntryPoint(amount) {
        const entryPoint = new ethers.Contract(
            this.entryPointAddress,
            ['function depositTo(address account) payable'],
            this.signer
        );

        const tx = await entryPoint.depositTo(this.accountAddress, { value: amount });
        return await tx.wait();
    }
}

// Bundler client for submitting UserOperations
class BundlerClient {
    constructor(bundlerUrl) {
        this.bundlerUrl = bundlerUrl;
    }

    async sendUserOperation(userOp, entryPoint) {
        const response = await fetch(`${this.bundlerUrl}/rpc`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                jsonrpc: '2.0',
                method: 'eth_sendUserOperation',
                params: [userOp, entryPoint],
                id: 1
            })
        });

        const result = await response.json();
        if (result.error) {
            throw new Error(result.error.message);
        }

        return result.result;
    }

    async getUserOperationReceipt(userOpHash) {
        const response = await fetch(`${this.bundlerUrl}/rpc`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                jsonrpc: '2.0',
                method: 'eth_getUserOperationReceipt',
                params: [userOpHash],
                id: 1
            })
        });

        const result = await response.json();
        return result.result;
    }
}

export { SmartAccountWallet, BundlerClient };


=== FILE: ./frontend/src/components/.gitkeep ===
# Place SmartAccountDashboard.jsx here



=== FILE: ./frontend/src/components/SmartAccountDashboard.jsx ===
import React, { useState, useEffect } from 'react';
import { Wallet, Key, Users, Send, CheckCircle, AlertCircle, Loader2, Copy, ExternalLink } from 'lucide-react';

// Mock addresses for demonstration (in production, these would be deployed contracts)
const MOCK_ADDRESSES = {
  entryPoint: '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789',
  factory: '0x1234567890123456789012345678901234567890',
  multiSigPlugin: '0x2345678901234567890123456789012345678901'
};

const SmartAccountDashboard = () => {
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [account, setAccount] = useState(null);
  const [balance, setBalance] = useState('0');
  const [owners, setOwners] = useState(['']);
  const [threshold, setThreshold] = useState(1);
  const [transactions, setTransactions] = useState([]);
  const [loading, setLoading] = useState(false);
  const [activeTab, setActiveTab] = useState('account');
  const [logs, setLogs] = useState([]);

  // Utility functions
  const formatEther = (wei) => {
    try {
      return (parseInt(wei) / 1e18).toFixed(4);
    } catch {
      return '0.0000';
    }
  };

  const parseEther = (ether) => {
    try {
      return (parseFloat(ether) * 1e18).toString();
    } catch {
      return '0';
    }
  };

  const getAddress = (address) => {
    // Simple address checksum (not full EIP-55, but good enough for demo)
    return address.toLowerCase().replace(/^0x/, '0x');
  };

  const keccak256 = async (data) => {
    const encoder = new TextEncoder();
    const dataBytes = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBytes);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return '0x' + hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  };

  // Initialize provider
  useEffect(() => {
    if (window.ethereum) {
      setProvider(window.ethereum);
    }
  }, []);

  // Connect wallet
  const connectWallet = async () => {
    try {
      setLoading(true);
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      setSigner(accounts[0]);
      addLog(`Connected wallet: ${accounts[0]}`, 'success');
    } catch (error) {
      addLog(`Error connecting wallet: ${error.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Create smart account (simulated)
  const createSmartAccount = async () => {
    try {
      setLoading(true);
      // In production, this would interact with the factory contract
      const timestamp = Date.now().toString();
      const hash = await keccak256(timestamp);
      const mockAccountAddress = '0x' + hash.slice(-40);
      
      setAccount({
        address: mockAccountAddress,
        owners: owners.filter(o => o),
        threshold: threshold,
        nonce: 0
      });
      
      addLog(`Smart account created: ${mockAccountAddress}`, 'success');
      
      // Simulate initial balance
      setBalance(parseEther('1.0'));
    } catch (error) {
      addLog(`Error creating account: ${error.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Add log entry
  const addLog = (message, type = 'info') => {
    setLogs(prev => [{
      message,
      type,
      timestamp: new Date().toLocaleTimeString()
    }, ...prev].slice(0, 10));
  };

  // Submit transaction (simulated)
  const submitTransaction = async (to, value, data) => {
    try {
      setLoading(true);
      const txId = transactions.length;
      
      const newTx = {
        id: txId,
        to,
        value,
        data,
        confirmations: 1,
        executed: false,
        confirmedBy: [signer]
      };
      
      setTransactions(prev => [...prev, newTx]);
      addLog(`Transaction #${txId} submitted`, 'success');
      
      // Auto-execute if threshold is met
      if (newTx.confirmations >= account.threshold) {
        setTimeout(() => executeTransaction(txId), 1000);
      }
    } catch (error) {
      addLog(`Error submitting transaction: ${error.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Confirm transaction (simulated)
  const confirmTransaction = async (txId) => {
    try {
      setLoading(true);
      
      setTransactions(prev => prev.map(tx => {
        if (tx.id === txId && !tx.confirmedBy.includes(signer)) {
          const updated = {
            ...tx,
            confirmations: tx.confirmations + 1,
            confirmedBy: [...tx.confirmedBy, signer]
          };
          
          if (updated.confirmations >= account.threshold && !updated.executed) {
            setTimeout(() => executeTransaction(txId), 1000);
          }
          
          return updated;
        }
        return tx;
      }));
      
      addLog(`Transaction #${txId} confirmed`, 'success');
    } catch (error) {
      addLog(`Error confirming transaction: ${error.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  // Execute transaction (simulated)
  const executeTransaction = async (txId) => {
    setTransactions(prev => prev.map(tx => {
      if (tx.id === txId) {
        addLog(`Transaction #${txId} executed`, 'success');
        return { ...tx, executed: true };
      }
      return tx;
    }));
  };

  // Copy to clipboard
  const copyToClipboard = (text) => {
    navigator.clipboard.writeText(text);
    addLog('Copied to clipboard', 'info');
  };

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="bg-gray-800 rounded-lg p-6 mb-6">
          <h1 className="text-3xl font-bold mb-4 flex items-center gap-3">
            <Wallet className="text-blue-500" />
            ERC-4337 & ERC-6900 Multi-Sig Wallet
          </h1>
          <p className="text-gray-400">
            Test implementation of modular smart accounts with multi-signature functionality
          </p>
        </div>

        {/* Connection Status */}
        <div className="bg-gray-800 rounded-lg p-6 mb-6">
          {!signer ? (
            <button
              onClick={connectWallet}
              disabled={loading}
              className="bg-blue-600 hover:bg-blue-700 px-6 py-3 rounded-lg flex items-center gap-2 transition-colors"
            >
              {loading ? <Loader2 className="animate-spin" size={20} /> : <Key size={20} />}
              Connect Wallet
            </button>
          ) : (
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                <span className="text-gray-300">Connected: {signer.slice(0, 6)}...{signer.slice(-4)}</span>
              </div>
              {account && (
                <div className="flex items-center gap-2">
                  <span className="text-gray-400">Smart Account:</span>
                  <code className="bg-gray-700 px-3 py-1 rounded">{account.address.slice(0, 6)}...{account.address.slice(-4)}</code>
                  <button
                    onClick={() => copyToClipboard(account.address)}
                    className="text-gray-400 hover:text-white"
                  >
                    <Copy size={16} />
                  </button>
                </div>
              )}
            </div>
          )}
        </div>

        {/* Main Content */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Left Panel - Account Setup */}
          <div className="lg:col-span-1">
            <div className="bg-gray-800 rounded-lg p-6">
              <h2 className="text-xl font-semibold mb-4 flex items-center gap-2">
                <Users size={20} />
                Account Setup
              </h2>
              
              {!account ? (
                <div className="space-y-4">
                  <div>
                    <label className="block text-sm text-gray-400 mb-2">Owners</label>
                    {owners.map((owner, index) => (
                      <div key={index} className="flex gap-2 mb-2">
                        <input
                          type="text"
                          value={owner}
                          onChange={(e) => {
                            const newOwners = [...owners];
                            newOwners[index] = e.target.value;
                            setOwners(newOwners);
                          }}
                          placeholder="0x..."
                          className="flex-1 bg-gray-700 rounded px-3 py-2 text-sm"
                        />
                        {index === owners.length - 1 && (
                          <button
                            onClick={() => setOwners([...owners, ''])}
                            className="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-sm"
                          >
                            +
                          </button>
                        )}
                      </div>
                    ))}
                  </div>
                  
                  <div>
                    <label className="block text-sm text-gray-400 mb-2">Threshold</label>
                    <input
                      type="number"
                      value={threshold}
                      onChange={(e) => setThreshold(Math.max(1, parseInt(e.target.value) || 1))}
                      min="1"
                      max={owners.filter(o => o).length || 1}
                      className="w-full bg-gray-700 rounded px-3 py-2 text-sm"
                    />
                  </div>
                  
                  <button
                    onClick={createSmartAccount}
                    disabled={!signer || loading || owners.filter(o => o).length < threshold}
                    className="w-full bg-green-600 hover:bg-green-700 disabled:bg-gray-600 px-4 py-2 rounded flex items-center justify-center gap-2 transition-colors"
                  >
                    {loading ? <Loader2 className="animate-spin" size={20} /> : <Wallet size={20} />}
                    Create Smart Account
                  </button>
                </div>
              ) : (
                <div className="space-y-4">
                  <div className="bg-gray-700 rounded p-4">
                    <p className="text-sm text-gray-400">Address</p>
                    <p className="font-mono text-xs break-all">{account.address}</p>
                  </div>
                  
                  <div className="bg-gray-700 rounded p-4">
                    <p className="text-sm text-gray-400">Balance</p>
                    <p className="text-2xl font-semibold">{formatEther(balance)} ETH</p>
                  </div>
                  
                  <div className="bg-gray-700 rounded p-4">
                    <p className="text-sm text-gray-400 mb-2">Owners ({account.owners.length})</p>
                    {account.owners.map((owner, i) => (
                      <p key={i} className="font-mono text-xs">{owner}</p>
                    ))}
                  </div>
                  
                  <div className="bg-gray-700 rounded p-4">
                    <p className="text-sm text-gray-400">Threshold</p>
                    <p className="text-xl">{account.threshold} of {account.owners.length}</p>
                  </div>
                </div>
              )}
            </div>
          </div>

          {/* Right Panel - Transactions */}
          <div className="lg:col-span-2">
            <div className="bg-gray-800 rounded-lg p-6">
              {/* Tabs */}
              <div className="flex gap-4 mb-6 border-b border-gray-700">
                <button
                  onClick={() => setActiveTab('send')}
                  className={`pb-3 px-1 ${activeTab === 'send' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-400'}`}
                >
                  Send Transaction
                </button>
                <button
                  onClick={() => setActiveTab('transactions')}
                  className={`pb-3 px-1 ${activeTab === 'transactions' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-400'}`}
                >
                  Transactions ({transactions.length})
                </button>
                <button
                  onClick={() => setActiveTab('logs')}
                  className={`pb-3 px-1 ${activeTab === 'logs' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-400'}`}
                >
                  Activity Logs
                </button>
              </div>

              {/* Send Transaction Tab */}
              {activeTab === 'send' && account && (
                <form
                  onSubmit={(e) => {
                    e.preventDefault();
                    const formData = new FormData(e.target);
                    submitTransaction(
                      formData.get('to'),
                      parseEther(formData.get('value') || '0'),
                      formData.get('data') || '0x'
                    );
                    e.target.reset();
                  }}
                  className="space-y-4"
                >
                  <div>
                    <label className="block text-sm text-gray-400 mb-2">To Address</label>
                    <input
                      name="to"
                      type="text"
                      required
                      placeholder="0x..."
                      className="w-full bg-gray-700 rounded px-3 py-2"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-sm text-gray-400 mb-2">Value (ETH)</label>
                    <input
                      name="value"
                      type="number"
                      step="0.0001"
                      placeholder="0.0"
                      className="w-full bg-gray-700 rounded px-3 py-2"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-sm text-gray-400 mb-2">Data (optional)</label>
                    <input
                      name="data"
                      type="text"
                      placeholder="0x..."
                      className="w-full bg-gray-700 rounded px-3 py-2"
                    />
                  </div>
                  
                  <button
                    type="submit"
                    disabled={loading}
                    className="w-full bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 px-4 py-2 rounded flex items-center justify-center gap-2"
                  >
                    {loading ? <Loader2 className="animate-spin" size={20} /> : <Send size={20} />}
                    Submit Transaction
                  </button>
                </form>
              )}

              {/* Transactions Tab */}
              {activeTab === 'transactions' && (
                <div className="space-y-4">
                  {transactions.length === 0 ? (
                    <p className="text-gray-400 text-center py-8">No transactions yet</p>
                  ) : (
                    transactions.map(tx => (
                      <div key={tx.id} className="bg-gray-700 rounded-lg p-4">
                        <div className="flex justify-between items-start mb-3">
                          <div>
                            <p className="font-semibold">Transaction #{tx.id}</p>
                            <p className="text-sm text-gray-400">To: {tx.to.slice(0, 10)}...{tx.to.slice(-8)}</p>
                            <p className="text-sm text-gray-400">Value: {formatEther(tx.value)} ETH</p>
                          </div>
                          <div className="text-right">
                            {tx.executed ? (
                              <span className="bg-green-600 px-3 py-1 rounded-full text-sm flex items-center gap-1">
                                <CheckCircle size={16} />
                                Executed
                              </span>
                            ) : (
                              <span className="bg-yellow-600 px-3 py-1 rounded-full text-sm">
                                {tx.confirmations}/{account.threshold} confirmations
                              </span>
                            )}
                          </div>
                        </div>
                        
                        {!tx.executed && !tx.confirmedBy.includes(signer) && (
                          <button
                            onClick={() => confirmTransaction(tx.id)}
                            disabled={loading}
                            className="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded text-sm flex items-center gap-2"
                          >
                            <CheckCircle size={16} />
                            Confirm
                          </button>
                        )}
                      </div>
                    ))
                  )}
                </div>
              )}

              {/* Logs Tab */}
              {activeTab === 'logs' && (
                <div className="space-y-2">
                  {logs.length === 0 ? (
                    <p className="text-gray-400 text-center py-8">No activity yet</p>
                  ) : (
                    logs.map((log, i) => (
                      <div
                        key={i}
                        className={`flex items-start gap-3 p-3 rounded ${
                          log.type === 'error' ? 'bg-red-900/20' : 
                          log.type === 'success' ? 'bg-green-900/20' : 
                          'bg-gray-700/50'
                        }`}
                      >
                        {log.type === 'error' ? (
                          <AlertCircle className="text-red-500 mt-0.5" size={16} />
                        ) : log.type === 'success' ? (
                          <CheckCircle className="text-green-500 mt-0.5" size={16} />
                        ) : (
                          <div className="w-4" />
                        )}
                        <div className="flex-1">
                          <p className="text-sm">{log.message}</p>
                          <p className="text-xs text-gray-500">{log.timestamp}</p>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              )}
            </div>
          </div>
        </div>

        {/* Info Panel */}
        <div className="mt-6 bg-gray-800 rounded-lg p-6">
          <h3 className="text-lg font-semibold mb-3">Implementation Details</h3>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
            <div>
              <p className="text-gray-400">ERC-4337 Features</p>
              <ul className="mt-1 text-gray-300 space-y-1">
                <li>â€¢ Account abstraction</li>
                <li>â€¢ UserOperation validation</li>
                <li>â€¢ Gas sponsorship ready</li>
              </ul>
            </div>
            <div>
              <p className="text-gray-400">ERC-6900 Features</p>
              <ul className="mt-1 text-gray-300 space-y-1">
                <li>â€¢ Modular plugin system</li>
                <li>â€¢ Multi-sig validation plugin</li>
                <li>â€¢ Extensible architecture</li>
              </ul>
            </div>
            <div>
              <p className="text-gray-400">Multi-Sig Features</p>
              <ul className="mt-1 text-gray-300 space-y-1">
                <li>â€¢ Configurable threshold</li>
                <li>â€¢ Multiple owner support</li>
                <li>â€¢ Transaction queue</li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default SmartAccountDashboard;


=== FILE: ./frontend/src/App.js ===
import React from 'react';
import SmartAccountDashboard from './components/SmartAccountDashboard';

function App() {
  return (
    <div className="App">
      <SmartAccountDashboard />
    </div>
  );
}

export default App;



=== FILE: ./test/MultiSig.test.js ===
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("MultiSig Smart Account", function () {
  let factory, multiSigPlugin, account;
  let owner1, owner2, owner3;

  beforeEach(async function () {
    [owner1, owner2, owner3] = await ethers.getSigners();
    
    // Deploy contracts
    // TODO: Add deployment logic
  });

  describe("Account Creation", function () {
    it("Should create a new smart account", async function () {
      // TODO: Add test
    });
  });

  describe("Multi-Sig Operations", function () {
    it("Should submit and confirm transactions", async function () {
      // TODO: Add test
    });
  });
});



=== FILE: ./fix.sh ===
#!/bin/bash

# ERC-4337 & ERC-6900 Project Fix Patch Script
# This script fixes all identified issues in the project

echo "================================================"
echo " Applying fixes to ERC-4337 & ERC-6900 Project"
echo "================================================"
echo ""

# 1. Fix SmartAccountFactory.sol
echo "[1/7] Fixing SmartAccountFactory.sol..."
cat > contracts/SmartAccountFactory.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./ModularSmartAccount.sol";

contract SmartAccountFactory {
    IEntryPoint public immutable entryPoint;
    
    event AccountCreated(address indexed account, address indexed owner, uint256 salt);
    
    constructor(IEntryPoint _entryPoint) {
        entryPoint = _entryPoint;
    }
    
    function createAccount(address owner, uint256 salt) external returns (address) {
        address account = address(new ModularSmartAccount{salt: bytes32(salt)}(entryPoint));
        emit AccountCreated(account, owner, salt);
        return account;
    }
    
    function getAddress(address owner, uint256 salt) external view returns (address) {
        return address(uint160(uint(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            keccak256(abi.encodePacked(type(ModularSmartAccount).creationCode, abi.encode(entryPoint)))
        )))));
    }
}
EOF

# 2. Update IEntryPoint.sol
echo "[2/7] Updating IEntryPoint.sol..."
cat > contracts/IEntryPoint.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

struct UserOperation {
    address sender;
    uint256 nonce;
    bytes initCode;
    bytes callData;
    uint256 callGasLimit;
    uint256 verificationGasLimit;
    uint256 preVerificationGas;
    uint256 maxFeePerGas;
    uint256 maxPriorityFeePerGas;
    bytes paymasterAndData;
    bytes signature;
}

interface IEntryPoint {
    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;
    function depositTo(address account) external payable;
    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;
    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);
}
EOF

# 3. Update IValidationPlugin.sol
echo "[3/7] Updating IValidationPlugin.sol..."
cat > contracts/interfaces/IValidationPlugin.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../IEntryPoint.sol";

interface IValidationPlugin {
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash
    ) external returns (uint256);
}
EOF

# 4. Create MockEntryPoint.sol
echo "[4/7] Creating MockEntryPoint.sol..."
cat > contracts/MockEntryPoint.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IEntryPoint.sol";

contract MockEntryPoint is IEntryPoint {
    mapping(address => uint256) public deposits;
    
    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);
    event Deposited(address indexed account, uint256 totalDeposit);
    event Withdrawn(address indexed account, address withdrawAddress, uint256 amount);
    
    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external override {
        for (uint256 i = 0; i < ops.length; i++) {
            UserOperation calldata op = ops[i];
            bytes32 userOpHash = getUserOpHash(op);
            
            // In a real implementation, this would validate and execute the operation
            // For mock purposes, we'll just emit an event
            emit UserOperationEvent(userOpHash, op.sender, address(0), op.nonce, true, 0, 0);
        }
    }
    
    function depositTo(address account) external payable override {
        deposits[account] += msg.value;
        emit Deposited(account, deposits[account]);
    }
    
    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external override {
        require(deposits[msg.sender] >= withdrawAmount, "Insufficient deposit");
        deposits[msg.sender] -= withdrawAmount;
        withdrawAddress.transfer(withdrawAmount);
        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);
    }
    
    function getUserOpHash(UserOperation calldata userOp) public pure override returns (bytes32) {
        return keccak256(abi.encode(
            userOp.sender,
            userOp.nonce,
            keccak256(userOp.initCode),
            keccak256(userOp.callData),
            userOp.callGasLimit,
            userOp.verificationGasLimit,
            userOp.preVerificationGas,
            userOp.maxFeePerGas,
            userOp.maxPriorityFeePerGas,
            keccak256(userOp.paymasterAndData)
        ));
    }
    
    function getDepositInfo(address account) external view returns (uint256) {
        return deposits[account];
    }
}
EOF

# 5. Update deploy.js
echo "[5/7] Updating deploy.js..."
cat > scripts/deploy.js << 'EOF'
// deploy.js - Deployment script for ERC-4337 & ERC-6900 contracts
const { ethers } = require("hardhat");
const fs = require('fs');

async function main() {
  console.log("ðŸš€ Deploying ERC-4337 & ERC-6900 Smart Account System...\n");

  // Get deployer
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with account:", deployer.address);
  console.log("Account balance:", ethers.utils.formatEther(await deployer.getBalance()), "ETH\n");

  // Deploy EntryPoint (or use existing one)
  console.log("1. Deploying EntryPoint...");
  let entryPoint;
  if (network.name === "localhost" || network.name === "hardhat") {
    const MockEntryPoint = await ethers.getContractFactory("MockEntryPoint");
    entryPoint = await MockEntryPoint.deploy();
    await entryPoint.deployed();
    console.log("   MockEntryPoint deployed to:", entryPoint.address);
  } else {
    // Use the official EntryPoint address for testnets/mainnet
    entryPoint = { address: "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789" };
    console.log("   Using official EntryPoint at:", entryPoint.address);
  }

  // Deploy MultiSigPlugin
  console.log("\n2. Deploying MultiSigPlugin...");
  const MultiSigPlugin = await ethers.getContractFactory("MultiSigPlugin");
  const multiSigPlugin = await MultiSigPlugin.deploy();
  await multiSigPlugin.deployed();
  console.log("   MultiSigPlugin deployed to:", multiSigPlugin.address);

  // Deploy SmartAccountFactory
  console.log("\n3. Deploying SmartAccountFactory...");
  const SmartAccountFactory = await ethers.getContractFactory("SmartAccountFactory");
  const factory = await SmartAccountFactory.deploy(entryPoint.address);
  await factory.deployed();
  console.log("   SmartAccountFactory deployed to:", factory.address);

  // Save deployment addresses
  const deploymentInfo = {
    network: network.name,
    chainId: network.config.chainId,
    deployer: deployer.address,
    contracts: {
      entryPoint: entryPoint.address,
      multiSigPlugin: multiSigPlugin.address,
      factory: factory.address
    },
    timestamp: new Date().toISOString()
  };

  // Write deployment info to file
  fs.writeFileSync(
    `deployments-${network.name}.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );

  // Update addresses.json
  const addressesPath = './scripts/addresses.json';
  let addresses = {};
  if (fs.existsSync(addressesPath)) {
    addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
  }
  
  addresses[network.name] = {
    entryPoint: entryPoint.address,
    factory: factory.address,
    multiSigPlugin: multiSigPlugin.address
  };
  
  fs.writeFileSync(addressesPath, JSON.stringify(addresses, null, 2));

  console.log("\nâœ… Deployment complete!");
  console.log("\nðŸ“„ Deployment info saved to:", `deployments-${network.name}.json`);
  
  // Verify contracts on Etherscan (if not on localhost)
  if (network.name !== "localhost" && network.name !== "hardhat") {
    console.log("\nðŸ” Verifying contracts on Etherscan...");
    
    await new Promise(resolve => setTimeout(resolve, 20000)); // Wait for Etherscan to index
    
    try {
      await hre.run("verify:verify", {
        address: multiSigPlugin.address,
        constructorArguments: [],
      });
      
      await hre.run("verify:verify", {
        address: factory.address,
        constructorArguments: [entryPoint.address],
      });
      
      console.log("âœ… Contracts verified!");
    } catch (error) {
      console.log("âš ï¸  Verification failed:", error.message);
    }
  }

  return deploymentInfo;
}

// Test script
async function testDeployment(deploymentInfo) {
  console.log("\nðŸ§ª Running deployment tests...\n");
  
  const [owner1, owner2, owner3] = await ethers.getSigners();
  
  // Get contract instances
  const factory = await ethers.getContractAt("SmartAccountFactory", deploymentInfo.contracts.factory);
  const multiSigPlugin = await ethers.getContractAt("MultiSigPlugin", deploymentInfo.contracts.multiSigPlugin);
  
  // Create a smart account
  console.log("1. Creating smart account...");
  const salt = 0;
  const tx = await factory.createAccount(owner1.address, salt);
  const receipt = await tx.wait();
  
  const accountAddress = await factory.getAddress(owner1.address, salt);
  console.log("   Smart account created at:", accountAddress);
  
  // Get account instance
  const account = await ethers.getContractAt("ModularSmartAccount", accountAddress);
  
  // Install multi-sig plugin
  console.log("\n2. Installing multi-sig plugin...");
  const owners = [owner1.address, owner2.address, owner3.address];
  const threshold = 2;
  
  const installData = ethers.utils.defaultAbiCoder.encode(
    ["address[]", "uint256"],
    [owners, threshold]
  );
  
  // Note: This would normally be done through a UserOperation
  const selector = "0x00000000"; // Custom selector for multi-sig
  await account.connect(owner1).installPlugin(selector, multiSigPlugin.address, installData);
  console.log("   Multi-sig plugin installed with", owners.length, "owners and threshold of", threshold);
  
  // Fund the account
  console.log("\n3. Funding account...");
  await owner1.sendTransaction({
    to: accountAddress,
    value: ethers.utils.parseEther("1.0")
  });
  const balance = await ethers.provider.getBalance(accountAddress);
  console.log("   Account balance:", ethers.utils.formatEther(balance), "ETH");
  
  console.log("\nâœ… All tests passed!");
}

// Run deployment and tests
main()
  .then(async (deploymentInfo) => {
    if (process.env.RUN_TESTS === "true") {
      await testDeployment(deploymentInfo);
    }
    process.exit(0);
  })
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
EOF

# 6. Clean up duplicate files
echo "[6/7] Cleaning up duplicate files..."
rm -f ./scripts/addresses.json~

# 7. Clean up ModularSmartAccount.sol to remove duplicates
echo "[7/7] Cleaning up ModularSmartAccount.sol..."
# Extract only the ModularSmartAccount contract from the file
cat > contracts/ModularSmartAccount.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IEntryPoint.sol";
import "./interfaces/IPlugin.sol";
import "./interfaces/IValidationPlugin.sol";

// Modular Smart Account (ERC-4337 + ERC-6900)
contract ModularSmartAccount {
    IEntryPoint public immutable entryPoint;
    uint256 public nonce;
    
    mapping(bytes4 => address) public plugins;
    
    event PluginInstalled(bytes4 indexed selector, address indexed plugin);
    event PluginUninstalled(bytes4 indexed selector);
    event Received(address indexed sender, uint256 amount);
    
    modifier onlyEntryPoint() {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        _;
    }
    
    modifier onlySelf() {
        require(msg.sender == address(this), "Only self");
        _;
    }
    
    constructor(IEntryPoint _entryPoint) {
        entryPoint = _entryPoint;
    }
    
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
    
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external onlyEntryPoint returns (uint256 validationData) {
        // Check if we need to pay missing funds
        if (missingAccountFunds > 0) {
            (bool success,) = payable(msg.sender).call{value: missingAccountFunds}("");
            require(success, "Failed to pay missing funds");
        }
        
        // Get the validation plugin
        bytes4 selector = bytes4(userOp.callData[:4]);
        address plugin = plugins[selector];
        
        if (plugin != address(0)) {
            return IValidationPlugin(plugin).validateUserOp(userOp, userOpHash);
        }
        
        // Default validation (single owner)
        return _validateSignature(userOp, userOpHash);
    }
    
    function _validateSignature(
        UserOperation calldata userOp,
        bytes32 userOpHash
    ) internal view returns (uint256) {
        // Simple signature validation for MVP
        bytes32 hash = keccak256(abi.encodePacked(userOpHash, address(this), block.chainid));
        address signer = recoverSigner(hash, userOp.signature);
        
        // For MVP, we'll accept any valid signature
        if (signer != address(0)) {
            return 0; // Valid
        }
        return 1; // Invalid
    }
    
    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) {
            return address(0);
        }
        
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        
        if (v < 27) {
            v += 27;
        }
        
        if (v != 27 && v != 28) {
            return address(0);
        }
        
        return ecrecover(hash, v, r, s);
    }
    
    function installPlugin(bytes4 selector, address plugin, bytes calldata data) external onlySelf {
        require(plugins[selector] == address(0), "Plugin already installed");
        require(plugin != address(0), "Invalid plugin address");
        
        plugins[selector] = plugin;
        IPlugin(plugin).onInstall(data);
        
        emit PluginInstalled(selector, plugin);
    }
    
    function uninstallPlugin(bytes4 selector, bytes calldata data) external onlySelf {
        address plugin = plugins[selector];
        require(plugin != address(0), "Plugin not installed");
        
        delete plugins[selector];
        IPlugin(plugin).onUninstall(data);
        
        emit PluginUninstalled(selector);
    }
    
    function execute(address to, uint256 value, bytes calldata data) external {
        require(msg.sender == address(this) || msg.sender == address(entryPoint), "Unauthorized");
        
        (bool success, bytes memory result) = to.call{value: value}(data);
        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }
    }
    
    function executeBatch(
        address[] calldata to,
        uint256[] calldata value,
        bytes[] calldata data
    ) external {
        require(msg.sender == address(this) || msg.sender == address(entryPoint), "Unauthorized");
        require(to.length == value.length && to.length == data.length, "Mismatched arrays");
        
        for (uint256 i = 0; i < to.length; i++) {
            (bool success, bytes memory result) = to[i].call{value: value[i]}(data[i]);
            if (!success) {
                assembly {
                    revert(add(result, 32), mload(result))
                }
            }
        }
    }
}
EOF

echo ""
echo "================================================"
echo "[+] All fixes applied successfully!"
echo "================================================"
echo ""
echo "Next steps:"
echo "1. Run: npm install"
echo "2. Run: npx hardhat compile"
echo "3. Deploy contracts: npx hardhat run scripts/deploy.js --network localhost"
echo ""
echo "[i] The project should now compile and deploy correctly!"


=== FILE: ./hardhat.config.js ===
require("@nomiclabs/hardhat-waffle");
require("@nomiclabs/hardhat-etherscan");
require("dotenv").config();

module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    hardhat: {
      chainId: 31337
    },
    localhost: {
      url: "http://127.0.0.1:8545"
    },
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 11155111
    },
    holesky: {
      url: process.env.HOLESKY_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 17000
    },
    polygon_mumbai: {
      url: process.env.POLYGON_MUMBAI_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 80001
    },
    arbitrum_sepolia: {
      url: process.env.ARBITRUM_SEPOLIA_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 421614
    }
  },
  etherscan: {
    apiKey: {
      sepolia: process.env.ETHERSCAN_API_KEY,
      holesky: process.env.ETHERSCAN_API_KEY,
      polygonMumbai: process.env.POLYGONSCAN_API_KEY,
      arbitrumSepolia: process.env.ARBISCAN_API_KEY
    }
  }
};


=== FILE: ./contracts/IEntryPoint.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

struct UserOperation {
    address sender;
    uint256 nonce;
    bytes initCode;
    bytes callData;
    uint256 callGasLimit;
    uint256 verificationGasLimit;
    uint256 preVerificationGas;
    uint256 maxFeePerGas;
    uint256 maxPriorityFeePerGas;
    bytes paymasterAndData;
    bytes signature;
}

interface IEntryPoint {
    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external;
    function depositTo(address account) external payable;
    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external;
    function getUserOpHash(UserOperation calldata userOp) external view returns (bytes32);
}



=== FILE: ./contracts/MultiSigPlugin.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./interfaces/IPlugin.sol";
import "./interfaces/IValidationPlugin.sol";
import "./interfaces/IExecutionPlugin.sol";

/**
 * @title MultiSigPlugin
 * @notice ERC-6900 compliant multi-signature plugin for modular smart accounts
 * @dev Implements validation and execution logic for multi-signature operations
 */
contract MultiSigPlugin is IPlugin, IValidationPlugin, IExecutionPlugin {
    // ===================== Structs =====================
    
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
        uint256 timestamp;
        bytes32 txHash;
    }
    
    struct AccountConfig {
        address[] owners;
        mapping(address => bool) isOwner;
        uint256 threshold;
        uint256 transactionCount;
        bool initialized;
    }
    
    // ===================== State Variables =====================
    
    // Account => Configuration
    mapping(address => AccountConfig) private accountConfigs;
    
    // Account => Transaction ID => Transaction
    mapping(address => mapping(uint256 => Transaction)) public transactions;
    
    // Account => Transaction ID => Owner => Confirmed
    mapping(address => mapping(uint256 => mapping(address => bool))) public confirmations;
    
    // Account => Owner => List of transaction IDs
    mapping(address => mapping(address => uint256[])) public ownerTransactions;
    
    // ===================== Events =====================
    
    event PluginInstalled(address indexed account, address[] owners, uint256 threshold);
    event PluginUninstalled(address indexed account);
    event OwnerAdded(address indexed account, address indexed owner);
    event OwnerRemoved(address indexed account, address indexed owner);
    event ThresholdChanged(address indexed account, uint256 oldThreshold, uint256 newThreshold);
    event TransactionSubmitted(
        address indexed account, 
        uint256 indexed txId, 
        address indexed submitter,
        address to,
        uint256 value,
        bytes data
    );
    event TransactionConfirmed(address indexed account, uint256 indexed txId, address indexed owner);
    event ConfirmationRevoked(address indexed account, uint256 indexed txId, address indexed owner);
    event TransactionExecuted(address indexed account, uint256 indexed txId, bool success);
    event TransactionFailed(address indexed account, uint256 indexed txId, bytes reason);
    
    // ===================== Modifiers =====================
    
    modifier onlyOwner(address account) {
        require(accountConfigs[account].isOwner[msg.sender], "Not an owner");
        _;
    }
    
    modifier txExists(address account, uint256 txId) {
        require(transactions[account][txId].to != address(0), "Transaction does not exist");
        _;
    }
    
    modifier notExecuted(address account, uint256 txId) {
        require(!transactions[account][txId].executed, "Transaction already executed");
        _;
    }
    
    modifier notConfirmed(address account, uint256 txId) {
        require(!confirmations[account][txId][msg.sender], "Transaction already confirmed");
        _;
    }
    
    // ===================== Plugin Installation =====================
    
    /**
     * @notice Install the plugin with initial configuration
     * @param data Encoded owners array and threshold
     */
    function onInstall(bytes calldata data) external override {
        require(!accountConfigs[msg.sender].initialized, "Already initialized");
        
        (address[] memory owners, uint256 threshold) = abi.decode(data, (address[], uint256));
        _validateOwnersAndThreshold(owners, threshold);
        
        AccountConfig storage config = accountConfigs[msg.sender];
        config.threshold = threshold;
        config.initialized = true;
        
        for (uint256 i = 0; i < owners.length; i++) {
            address owner = owners[i];
            require(owner != address(0), "Invalid owner address");
            require(!config.isOwner[owner], "Duplicate owner");
            
            config.owners.push(owner);
            config.isOwner[owner] = true;
        }
        
        emit PluginInstalled(msg.sender, owners, threshold);
    }
    
    /**
     * @notice Uninstall the plugin and clean up storage
     * @param data Unused parameter for interface compliance
     */
    function onUninstall(bytes calldata data) external override {
        AccountConfig storage config = accountConfigs[msg.sender];
        require(config.initialized, "Not initialized");
        
        // Clean up owners
        for (uint256 i = 0; i < config.owners.length; i++) {
            delete config.isOwner[config.owners[i]];
        }
        delete config.owners;
        
        // Clean up transactions
        for (uint256 i = 0; i < config.transactionCount; i++) {
            delete transactions[msg.sender][i];
        }
        
        delete accountConfigs[msg.sender];
        emit PluginUninstalled(msg.sender);
    }
    
    // ===================== Validation Functions =====================
    
    /**
     * @notice Validate a user operation for multi-sig requirements
     * @param userOp The user operation to validate
     * @param userOpHash Hash of the user operation
     * @return validationData 0 for success, 1 for failure
     */
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash
    ) external view override returns (uint256 validationData) {
        // Decode multi-sig validation data from signature
        (uint256 txId, address[] memory signers) = abi.decode(
            userOp.signature,
            (uint256, address[])
        );
        
        AccountConfig storage config = accountConfigs[userOp.sender];
        Transaction storage txn = transactions[userOp.sender][txId];
        
        // Verify transaction exists and matches
        if (txn.to == address(0) || txn.executed) {
            return 1; // Invalid
        }
        
        // Verify operation matches transaction
        bytes32 expectedHash = keccak256(abi.encode(txn.to, txn.value, txn.data));
        bytes32 actualHash = keccak256(userOp.callData);
        if (expectedHash != actualHash) {
            return 1; // Mismatch
        }
        
        // Count valid signatures
        uint256 validSignatures = 0;
        for (uint256 i = 0; i < signers.length; i++) {
            if (config.isOwner[signers[i]] && confirmations[userOp.sender][txId][signers[i]]) {
                validSignatures++;
            }
        }
        
        return validSignatures >= config.threshold ? 0 : 1;
    }
    
    // ===================== Transaction Management =====================
    
    /**
     * @notice Submit a new transaction for multi-sig approval
     * @param to Destination address
     * @param value ETH value to send
     * @param data Transaction data
     * @return txId Transaction ID
     */
    function submitTransaction(
        address to,
        uint256 value,
        bytes calldata data
    ) external onlyOwner(msg.sender) returns (uint256 txId) {
        require(to != address(0), "Invalid destination");
        
        AccountConfig storage config = accountConfigs[msg.sender];
        txId = config.transactionCount;
        
        transactions[msg.sender][txId] = Transaction({
            to: to,
            value: value,
            data: data,
            executed: false,
            confirmations: 0,
            timestamp: block.timestamp,
            txHash: keccak256(abi.encode(msg.sender, txId, to, value, data))
        });
        
        config.transactionCount++;
        
        emit TransactionSubmitted(msg.sender, txId, tx.origin, to, value, data);
        
        // Auto-confirm for submitter
        _confirmTransaction(msg.sender, txId);
    }
    
    /**
     * @notice Confirm a pending transaction
     * @param txId Transaction ID to confirm
     */
    function confirmTransaction(uint256 txId) 
        external 
        onlyOwner(msg.sender)
        txExists(msg.sender, txId)
        notExecuted(msg.sender, txId)
        notConfirmed(msg.sender, txId)
    {
        _confirmTransaction(msg.sender, txId);
    }
    
    /**
     * @notice Revoke a confirmation
     * @param txId Transaction ID
     */
    function revokeConfirmation(uint256 txId)
        external
        onlyOwner(msg.sender)
        txExists(msg.sender, txId)
        notExecuted(msg.sender, txId)
    {
        require(confirmations[msg.sender][txId][tx.origin], "Not confirmed");
        
        confirmations[msg.sender][txId][tx.origin] = false;
        transactions[msg.sender][txId].confirmations--;
        
        emit ConfirmationRevoked(msg.sender, txId, tx.origin);
    }
    
    /**
     * @notice Execute a confirmed transaction
     * @param txId Transaction ID to execute
     */
    function executeTransaction(uint256 txId)
        external
        onlyOwner(msg.sender)
        txExists(msg.sender, txId)
        notExecuted(msg.sender, txId)
    {
        Transaction storage txn = transactions[msg.sender][txId];
        AccountConfig storage config = accountConfigs[msg.sender];
        
        require(txn.confirmations >= config.threshold, "Insufficient confirmations");
        
        txn.executed = true;
        
        (bool success, bytes memory result) = txn.to.call{value: txn.value}(txn.data);
        
        if (success) {
            emit TransactionExecuted(msg.sender, txId, true);
        } else {
            emit TransactionFailed(msg.sender, txId, result);
            // Revert the execution status to allow retry
            txn.executed = false;
        }
    }
    
    // ===================== Owner Management =====================
    
    /**
     * @notice Add a new owner
     * @param owner Address to add as owner
     */
    function addOwner(address owner) external onlyOwner(msg.sender) {
        require(owner != address(0), "Invalid owner");
        
        AccountConfig storage config = accountConfigs[msg.sender];
        require(!config.isOwner[owner], "Already an owner");
        
        config.owners.push(owner);
        config.isOwner[owner] = true;
        
        emit OwnerAdded(msg.sender, owner);
    }
    
    /**
     * @notice Remove an existing owner
     * @param owner Address to remove
     */
    function removeOwner(address owner) external onlyOwner(msg.sender) {
        AccountConfig storage config = accountConfigs[msg.sender];
        require(config.isOwner[owner], "Not an owner");
        require(config.owners.length - 1 >= config.threshold, "Would break threshold");
        
        config.isOwner[owner] = false;
        
        // Remove from array
        for (uint256 i = 0; i < config.owners.length; i++) {
            if (config.owners[i] == owner) {
                config.owners[i] = config.owners[config.owners.length - 1];
                config.owners.pop();
                break;
            }
        }
        
        emit OwnerRemoved(msg.sender, owner);
    }
    
    /**
     * @notice Change the confirmation threshold
     * @param newThreshold New threshold value
     */
    function changeThreshold(uint256 newThreshold) external onlyOwner(msg.sender) {
        AccountConfig storage config = accountConfigs[msg.sender];
        _validateOwnersAndThreshold(config.owners, newThreshold);
        
        uint256 oldThreshold = config.threshold;
        config.threshold = newThreshold;
        
        emit ThresholdChanged(msg.sender, oldThreshold, newThreshold);
    }
    
    // ===================== View Functions =====================
    
    /**
     * @notice Get account configuration
     * @param account Account address
     * @return owners Array of owner addresses
     * @return threshold Confirmation threshold
     */
    function getAccountConfig(address account) 
        external 
        view 
        returns (address[] memory owners, uint256 threshold) 
    {
        AccountConfig storage config = accountConfigs[account];
        return (config.owners, config.threshold);
    }
    
    /**
     * @notice Get transaction details
     * @param account Account address
     * @param txId Transaction ID
     * @return Transaction details
     */
    function getTransaction(address account, uint256 txId) 
        external 
        view 
        returns (Transaction memory) 
    {
        return transactions[account][txId];
    }
    
    /**
     * @notice Get transaction confirmations
     * @param account Account address
     * @param txId Transaction ID
     * @return confirmedOwners List of owners who confirmed
     */
    function getConfirmations(address account, uint256 txId)
        external
        view
        returns (address[] memory confirmedOwners)
    {
        AccountConfig storage config = accountConfigs[account];
        uint256 count = 0;
        
        // Count confirmations
        for (uint256 i = 0; i < config.owners.length; i++) {
            if (confirmations[account][txId][config.owners[i]]) {
                count++;
            }
        }
        
        // Build array
        confirmedOwners = new address[](count);
        uint256 index = 0;
        for (uint256 i = 0; i < config.owners.length; i++) {
            if (confirmations[account][txId][config.owners[i]]) {
                confirmedOwners[index] = config.owners[i];
                index++;
            }
        }
    }
    
    /**
     * @notice Check if an address is an owner
     * @param account Account address
     * @param owner Address to check
     * @return bool True if owner
     */
    function isOwner(address account, address owner) external view returns (bool) {
        return accountConfigs[account].isOwner[owner];
    }
    
    /**
     * @notice Get pending transactions for an account
     * @param account Account address
     * @return pendingTxIds Array of pending transaction IDs
     */
    function getPendingTransactions(address account) 
        external 
        view 
        returns (uint256[] memory pendingTxIds) 
    {
        AccountConfig storage config = accountConfigs[account];
        uint256 pendingCount = 0;
        
        // Count pending transactions
        for (uint256 i = 0; i < config.transactionCount; i++) {
            if (!transactions[account][i].executed && transactions[account][i].to != address(0)) {
                pendingCount++;
            }
        }
        
        // Build array
        pendingTxIds = new uint256[](pendingCount);
        uint256 index = 0;
        for (uint256 i = 0; i < config.transactionCount; i++) {
            if (!transactions[account][i].executed && transactions[account][i].to != address(0)) {
                pendingTxIds[index] = i;
                index++;
            }
        }
    }
    
    // ===================== Internal Functions =====================
    
    function _confirmTransaction(address account, uint256 txId) internal {
        confirmations[account][txId][tx.origin] = true;
        transactions[account][txId].confirmations++;
        ownerTransactions[account][tx.origin].push(txId);
        
        emit TransactionConfirmed(account, txId, tx.origin);
    }
    
    function _validateOwnersAndThreshold(
        address[] memory owners,
        uint256 threshold
    ) internal pure {
        require(owners.length > 0, "No owners");
        require(threshold > 0, "Invalid threshold");
        require(threshold <= owners.length, "Threshold too high");
    }
}


=== FILE: ./contracts/README.md ===
# Smart Contracts

Place the following files here:
- ModularSmartAccount.sol
- MultiSigPlugin.sol  
- SmartAccountFactory.sol

These files contain the main implementation and should be added manually.



=== FILE: ./contracts/SmartAccountFactory.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./ModularSmartAccount.sol";

contract SmartAccountFactory {
    IEntryPoint public immutable entryPoint;
    
    event AccountCreated(address indexed account, address indexed owner, uint256 salt);
    
    constructor(IEntryPoint _entryPoint) {
        entryPoint = _entryPoint;
    }
    
    function createAccount(address owner, uint256 salt) external returns (address) {
        address account = address(new ModularSmartAccount{salt: bytes32(salt)}(entryPoint));
        emit AccountCreated(account, owner, salt);
        return account;
    }
    
    function getAddress(address owner, uint256 salt) external view returns (address) {
        return address(uint160(uint(keccak256(abi.encodePacked(
            bytes1(0xff),
            address(this),
            salt,
            keccak256(abi.encodePacked(type(ModularSmartAccount).creationCode, abi.encode(entryPoint)))
        )))));
    }
}



=== FILE: ./contracts/ModularSmartAccount.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IEntryPoint.sol";
import "./interfaces/IPlugin.sol";
import "./interfaces/IValidationPlugin.sol";

// Modular Smart Account (ERC-4337 + ERC-6900)
contract ModularSmartAccount {
    IEntryPoint public immutable entryPoint;
    uint256 public nonce;
    
    mapping(bytes4 => address) public plugins;
    
    event PluginInstalled(bytes4 indexed selector, address indexed plugin);
    event PluginUninstalled(bytes4 indexed selector);
    event Received(address indexed sender, uint256 amount);
    
    modifier onlyEntryPoint() {
        require(msg.sender == address(entryPoint), "Only EntryPoint");
        _;
    }
    
    modifier onlySelf() {
        require(msg.sender == address(this), "Only self");
        _;
    }
    
    constructor(IEntryPoint _entryPoint) {
        entryPoint = _entryPoint;
    }
    
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
    
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash,
        uint256 missingAccountFunds
    ) external onlyEntryPoint returns (uint256 validationData) {
        // Check if we need to pay missing funds
        if (missingAccountFunds > 0) {
            (bool success,) = payable(msg.sender).call{value: missingAccountFunds}("");
            require(success, "Failed to pay missing funds");
        }
        
        // Get the validation plugin
        bytes4 selector = bytes4(userOp.callData[:4]);
        address plugin = plugins[selector];
        
        if (plugin != address(0)) {
            return IValidationPlugin(plugin).validateUserOp(userOp, userOpHash);
        }
        
        // Default validation (single owner)
        return _validateSignature(userOp, userOpHash);
    }
    
    function _validateSignature(
        UserOperation calldata userOp,
        bytes32 userOpHash
    ) internal view returns (uint256) {
        // Simple signature validation for MVP
        bytes32 hash = keccak256(abi.encodePacked(userOpHash, address(this), block.chainid));
        address signer = recoverSigner(hash, userOp.signature);
        
        // For MVP, we'll accept any valid signature
        if (signer != address(0)) {
            return 0; // Valid
        }
        return 1; // Invalid
    }
    
    function recoverSigner(bytes32 hash, bytes memory signature) internal pure returns (address) {
        if (signature.length != 65) {
            return address(0);
        }
        
        bytes32 r;
        bytes32 s;
        uint8 v;
        
        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
        
        if (v < 27) {
            v += 27;
        }
        
        if (v != 27 && v != 28) {
            return address(0);
        }
        
        return ecrecover(hash, v, r, s);
    }
    
    function installPlugin(bytes4 selector, address plugin, bytes calldata data) external onlySelf {
        require(plugins[selector] == address(0), "Plugin already installed");
        require(plugin != address(0), "Invalid plugin address");
        
        plugins[selector] = plugin;
        IPlugin(plugin).onInstall(data);
        
        emit PluginInstalled(selector, plugin);
    }
    
    function uninstallPlugin(bytes4 selector, bytes calldata data) external onlySelf {
        address plugin = plugins[selector];
        require(plugin != address(0), "Plugin not installed");
        
        delete plugins[selector];
        IPlugin(plugin).onUninstall(data);
        
        emit PluginUninstalled(selector);
    }
    
    function execute(address to, uint256 value, bytes calldata data) external {
        require(msg.sender == address(this) || msg.sender == address(entryPoint), "Unauthorized");
        
        (bool success, bytes memory result) = to.call{value: value}(data);
        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }
    }
    
    function executeBatch(
        address[] calldata to,
        uint256[] calldata value,
        bytes[] calldata data
    ) external {
        require(msg.sender == address(this) || msg.sender == address(entryPoint), "Unauthorized");
        require(to.length == value.length && to.length == data.length, "Mismatched arrays");
        
        for (uint256 i = 0; i < to.length; i++) {
            (bool success, bytes memory result) = to[i].call{value: value[i]}(data[i]);
            if (!success) {
                assembly {
                    revert(add(result, 32), mload(result))
                }
            }
        }
    }
}



=== FILE: ./contracts/interfaces/IExecutionPlugin.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IExecutionPlugin {
    // Add execution-related functions as needed
}



=== FILE: ./contracts/interfaces/IPlugin.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IPlugin {
    function onInstall(bytes calldata data) external;
    function onUninstall(bytes calldata data) external;
}



=== FILE: ./contracts/interfaces/IValidationPlugin.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "../IEntryPoint.sol";

interface IValidationPlugin {
    function validateUserOp(
        UserOperation calldata userOp,
        bytes32 userOpHash
    ) external returns (uint256);
}



=== FILE: ./contracts/MockEntryPoint.sol ===
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./IEntryPoint.sol";

contract MockEntryPoint is IEntryPoint {
    mapping(address => uint256) public deposits;
    
    event UserOperationEvent(bytes32 indexed userOpHash, address indexed sender, address indexed paymaster, uint256 nonce, bool success, uint256 actualGasCost, uint256 actualGasUsed);
    event Deposited(address indexed account, uint256 totalDeposit);
    event Withdrawn(address indexed account, address withdrawAddress, uint256 amount);
    
    function handleOps(UserOperation[] calldata ops, address payable beneficiary) external override {
        for (uint256 i = 0; i < ops.length; i++) {
            UserOperation calldata op = ops[i];
            bytes32 userOpHash = getUserOpHash(op);
            
            // In a real implementation, this would validate and execute the operation
            // For mock purposes, we'll just emit an event
            emit UserOperationEvent(userOpHash, op.sender, address(0), op.nonce, true, 0, 0);
        }
    }
    
    function depositTo(address account) external payable override {
        deposits[account] += msg.value;
        emit Deposited(account, deposits[account]);
    }
    
    function withdrawTo(address payable withdrawAddress, uint256 withdrawAmount) external override {
        require(deposits[msg.sender] >= withdrawAmount, "Insufficient deposit");
        deposits[msg.sender] -= withdrawAmount;
        withdrawAddress.transfer(withdrawAmount);
        emit Withdrawn(msg.sender, withdrawAddress, withdrawAmount);
    }
    
    function getUserOpHash(UserOperation calldata userOp) public pure override returns (bytes32) {
        return keccak256(abi.encode(
            userOp.sender,
            userOp.nonce,
            keccak256(userOp.initCode),
            keccak256(userOp.callData),
            userOp.callGasLimit,
            userOp.verificationGasLimit,
            userOp.preVerificationGas,
            userOp.maxFeePerGas,
            userOp.maxPriorityFeePerGas,
            keccak256(userOp.paymasterAndData)
        ));
    }
    
    function getDepositInfo(address account) external view returns (uint256) {
        return deposits[account];
    }
}



=== FILE: ./README.md ===
# ERC-4337 & ERC-6900 Smart Account MVP

```
 _____ ____   ____      _  _  _____ _____ _____ 
| ____|  _ \ / ___|    | || ||___ /|___ /|___  |
|  _| | |_) | |   _____| || |_ |_ \  |_ \   / / 
| |___|  _ <| |__|_____|__   _|__) |___) | / /  
|_____|_| \_\\____|       |_| |____/|____/ /_/   
                                                 
 __  __       _ _   _       ____  _       
|  \/  |_   _| | |_(_)     / ___|(_) __ _ 
| |\/| | | | | | __| |____| |  _ | |/ _` |
| |  | | |_| | | |_| |____| |_| || | (_| |
|_|  |_|\__,_|_|\__|_|     \____||_|\__, |
                                    |___/ 
```

A complete implementation of ERC-4337 Account Abstraction with ERC-6900 modular plugins, featuring multi-signature functionality.

## [+] Features

- **ERC-4337 Account Abstraction**: Full implementation of smart contract wallets
- **ERC-6900 Modular System**: Plugin-based architecture for extensibility
- **Multi-Signature Support**: Configurable threshold signatures
- **React GUI**: Interactive interface for testing
- **Complete Wallet SDK**: JavaScript library for integration

## [*] Prerequisites

- Node.js v16+
- npm or yarn
- MetaMask or any Web3 wallet
- Hardhat for contract deployment

## [!] Installation

1. **Clone the repository**
```bash
git clone <your-repo>
cd erc4337-multisig-mvp
```

2. **Install dependencies**
```bash
npm install
```

3. **Install Hardhat and dependencies**
```bash
npm install --save-dev hardhat @nomiclabs/hardhat-ethers @nomiclabs/hardhat-waffle ethereum-waffle chai ethers
```

4. **Create `.env` file**
```bash
# For testnet deployment
SEPOLIA_RPC_URL=your_rpc_url
MUMBAI_RPC_URL=your_rpc_url
PRIVATE_KEY=your_private_key
ETHERSCAN_API_KEY=your_api_key
```

## [#] Project Structure

```
â”œâ”€â”€ contracts/
â”‚   â”œâ”€â”€ ModularSmartAccount.sol    # Main smart account implementation
â”‚   â”œâ”€â”€ MultiSigPlugin.sol         # Multi-signature plugin
â”‚   â””â”€â”€ SmartAccountFactory.sol    # Factory for deploying accounts
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ wallet.js                  # JavaScript wallet SDK
â”‚   â””â”€â”€ SmartAccountDashboard.jsx  # React GUI component
â”œâ”€â”€ scripts/
â”‚   â””â”€â”€ deploy.js                  # Deployment script
â””â”€â”€ README.md
```

## [>] Quick Start

### 1. Deploy Contracts

**Local deployment:**
```bash
npx hardhat node  # In one terminal
npx hardhat run scripts/deploy.js --network localhost  # In another terminal
```

**Testnet deployment:**
```bash
npx hardhat run scripts/deploy.js --network sepolia
```

### 2. Run the GUI

Create a simple React app:
```bash
npx create-react-app smart-account-gui
cd smart-account-gui
npm install ethers lucide-react
```

Copy the `SmartAccountDashboard.jsx` to `src/App.js` and run:
```bash
npm start
```

### 3. Using the Wallet SDK

```javascript
import { SmartAccountWallet } from './wallet.js';

// Initialize wallet
const wallet = new SmartAccountWallet(
  provider,
  entryPointAddress,
  factoryAddress,
  multiSigPluginAddress
);

// Create account
await wallet.init(privateKey);
const accountAddress = await wallet.createAccount();

// Install multi-sig plugin
await wallet.installMultiSigPlugin(
  [owner1, owner2, owner3],  // owners
  2                          // threshold
);

// Submit transaction
await wallet.submitMultiSigTransaction(
  recipientAddress,
  ethers.utils.parseEther("0.1"),
  "0x"  // data
);
```

## [@] Contract Interfaces

### ModularSmartAccount
- `validateUserOp()`: Validates UserOperations (ERC-4337)
- `installPlugin()`: Installs a new plugin (ERC-6900)
- `execute()`: Executes transactions
- `executeBatch()`: Executes multiple transactions

### MultiSigPlugin
- `onInstall()`: Configures owners and threshold
- `submitTransaction()`: Creates new multi-sig transaction
- `confirmTransaction()`: Adds confirmation
- `executeTransaction()`: Executes when threshold is met

## [?] Testing

Run the test suite:
```bash
RUN_TESTS=true npx hardhat run scripts/deploy.js --network localhost
```

## [~] Configuration

### EntryPoint Address
- Mainnet/Testnet: `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789`
- Local: Deploy your own or use the one from deployment

### Gas Configuration
Adjust in `wallet.js`:
```javascript
callGasLimit: 200000,
verificationGasLimit: 100000,
preVerificationGas: 50000,
```

## [=] Network Support

- Ethereum Mainnet
- Sepolia Testnet
- Polygon Mumbai
- Local Hardhat Network

## [!] Security Considerations

This is an MVP implementation. For production:
- Audit all smart contracts
- Implement proper signature validation
- Add access control mechanisms
- Use a production-ready bundler
- Implement proper nonce management

## [i] Resources

- [ERC-4337 Specification](https://eips.ethereum.org/EIPS/eip-4337)
- [ERC-6900 Specification](https://eips.ethereum.org/EIPS/eip-6900)
- [Account Abstraction Documentation](https://docs.stackup.sh/)

## [&] Contributing

Feel free to submit issues and enhancement requests!

## [c] License

MIT License


=== FILE: ./setup-script.sh ===
#!/bin/bash

# ERC-4337 & ERC-6900 Smart Account MVP Setup Script
# This script creates the complete project structure with placeholder files

echo "============================================="
echo " ERC-4337 & ERC-6900 Smart Account MVP Setup"
echo "============================================="
echo ""

# Check if we're in a project directory
if [ ! -f "package.json" ] && [ -z "$(ls -A)" ]; then
    echo "[>] Initializing project in current directory: $(pwd)"
else
    echo "[!] Warning: Current directory is not empty."
    read -p "Continue anyway? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "[x] Setup cancelled."
        exit 1
    fi
fi

# Create directory structure
echo "[>] Creating directory structure..."
mkdir -p contracts
mkdir -p frontend/public
mkdir -p frontend/src/components
mkdir -p frontend/src/utils
mkdir -p scripts
mkdir -p test

# Create root files
echo "[>] Creating root configuration files..."

# Create package.json
cat > package.json << 'EOF'
{
  "name": "erc4337-multisig-mvp",
  "version": "1.0.0",
  "description": "ERC-4337 & ERC-6900 Smart Account MVP with Multi-Sig",
  "scripts": {
    "compile": "hardhat compile",
    "deploy": "hardhat run scripts/deploy.js",
    "deploy:local": "hardhat run scripts/deploy.js --network localhost",
    "deploy:sepolia": "hardhat run scripts/deploy.js --network sepolia",
    "test": "hardhat test",
    "node": "hardhat node"
  },
  "keywords": ["erc4337", "erc6900", "smart-account", "multisig"],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@nomiclabs/hardhat-ethers": "^2.0.0",
    "@nomiclabs/hardhat-etherscan": "^3.0.0",
    "@nomiclabs/hardhat-waffle": "^2.0.0",
    "chai": "^4.2.0",
    "ethereum-waffle": "^3.0.0",
    "ethers": "^5.0.0",
    "hardhat": "^2.12.0"
  }
}
EOF

# Create hardhat.config.js
cat > hardhat.config.js << 'EOF'
require("@nomiclabs/hardhat-waffle");
require("@nomiclabs/hardhat-etherscan");
require("dotenv").config();

module.exports = {
  solidity: {
    version: "0.8.19",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200
      }
    }
  },
  networks: {
    hardhat: {
      chainId: 31337
    },
    localhost: {
      url: "http://127.0.0.1:8545"
    },
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
    },
    goerli: {
      url: process.env.GOERLI_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
    }
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};
EOF

# Create .env.example
cat > .env.example << 'EOF'
# RPC URLs
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_KEY
GOERLI_RPC_URL=https://goerli.infura.io/v3/YOUR_INFURA_KEY

# Private key (without 0x prefix)
PRIVATE_KEY=your_private_key_here

# Etherscan API key for verification
ETHERSCAN_API_KEY=your_etherscan_api_key
EOF

# Create .gitignore
cat > .gitignore << 'EOF'
# Dependencies
node_modules/
frontend/node_modules/

# Environment files
.env
.env.local

# Hardhat files
cache/
artifacts/
typechain/
typechain-types/

# Coverage
coverage/
coverage.json

# Builds
build/
dist/
frontend/build/

# IDE
.vscode/
.idea/

# OS
.DS_Store
*.log

# Deployment files
deployments-*.json
EOF

# Create contract placeholders
echo "[>] Creating contract placeholders..."

# EntryPoint interface placeholder
cat > contracts/IEntryPoint.sol << 'EOF'
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Placeholder for IEntryPoint interface
// Full implementation will be added manually
interface IEntryPoint {
    // ERC-4337 EntryPoint interface
}
EOF

# Create test file
cat > test/MultiSig.test.js << 'EOF'
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("MultiSig Smart Account", function () {
  let factory, multiSigPlugin, account;
  let owner1, owner2, owner3;

  beforeEach(async function () {
    [owner1, owner2, owner3] = await ethers.getSigners();
    
    // Deploy contracts
    // TODO: Add deployment logic
  });

  describe("Account Creation", function () {
    it("Should create a new smart account", async function () {
      // TODO: Add test
    });
  });

  describe("Multi-Sig Operations", function () {
    it("Should submit and confirm transactions", async function () {
      // TODO: Add test
    });
  });
});
EOF

# Create frontend files
echo "[>] Creating frontend structure..."

# Frontend package.json
cat > frontend/package.json << 'EOF'
{
  "name": "erc4337-multisig-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "5.0.1",
    "lucide-react": "^0.263.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": ["react-app"]
  },
  "browserslist": {
    "production": [">0.2%", "not dead", "not op_mini all"],
    "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
  }
}
EOF

# Frontend index.html
cat > frontend/public/index.html << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="ERC-4337 & ERC-6900 Multi-Sig Wallet" />
  <title>Smart Account Multi-Sig</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
</body>
</html>
EOF

# Frontend index.js
cat > frontend/src/index.js << 'EOF'
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
EOF

# Frontend App.js
cat > frontend/src/App.js << 'EOF'
import React from 'react';
import SmartAccountDashboard from './components/SmartAccountDashboard';

function App() {
  return (
    <div className="App">
      <SmartAccountDashboard />
    </div>
  );
}

export default App;
EOF

# Create placeholder for components
cat > frontend/src/components/.gitkeep << 'EOF'
# Place SmartAccountDashboard.jsx here
EOF

cat > frontend/src/utils/.gitkeep << 'EOF'
# Place wallet.js here
EOF

# Create deployment addresses tracker
cat > scripts/addresses.json << 'EOF'
{
  "localhost": {
    "entryPoint": "",
    "factory": "",
    "multiSigPlugin": ""
  },
  "sepolia": {
    "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "factory": "",
    "multiSigPlugin": ""
  },
  "goerli": {
    "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "factory": "",
    "multiSigPlugin": ""
  }
}
EOF

# Create deployment helper script
cat > scripts/verify.js << 'EOF'
// Contract verification script
const hre = require("hardhat");

async function main() {
  console.log("[>] Verifying contracts on Etherscan...");
  
  // Load deployment addresses
  const addresses = require("./addresses.json")[hre.network.name];
  
  if (addresses.multiSigPlugin) {
    await hre.run("verify:verify", {
      address: addresses.multiSigPlugin,
      constructorArguments: [],
    });
  }
  
  if (addresses.factory) {
    await hre.run("verify:verify", {
      address: addresses.factory,
      constructorArguments: [addresses.entryPoint],
    });
  }
  
  console.log("[+] Verification complete!");
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
EOF

# Create main README placeholder
cat > README.md << 'EOF'
# ERC-4337 & ERC-6900 Smart Account MVP

[!] Full README will be added manually

## Quick Setup

1. Install dependencies:
   ```bash
   npm install
   cd frontend && npm install
   ```

2. Copy environment file:
   ```bash
   cp .env.example .env
   # Edit .env with your values
   ```

3. Deploy contracts:
   ```bash
   npm run deploy:local
   ```

4. Start frontend:
   ```bash
   cd frontend && npm start
   ```
EOF

# Create contract placeholders note
cat > contracts/README.md << 'EOF'
# Smart Contracts

Place the following files here:
- ModularSmartAccount.sol
- MultiSigPlugin.sol  
- SmartAccountFactory.sol

These files contain the main implementation and should be added manually.
EOF

# Make scripts executable
chmod +x scripts/*.js

# Final message
echo ""
echo "============================================="
echo "[+] Project structure created successfully!"
echo "============================================="
echo ""
echo "Next steps:"
echo "1. Copy the generated contract files to contracts/"
echo "2. Copy SmartAccountDashboard.jsx to frontend/src/components/"
echo "3. Copy wallet.js to frontend/src/utils/"
echo "4. Copy deploy.js to scripts/"
echo "5. Copy the full README.md to the root"
echo ""
echo "Then run:"
echo "  npm install"
echo "  cd frontend && npm install"
echo ""
echo "[i] Don't forget to:"
echo "  - Copy .env.example to .env and add your keys"
echo "  - Update contract addresses in scripts/addresses.json after deployment"
echo ""


=== FILE: ./.gitignore ===
# Dependencies
node_modules/
frontend/node_modules/

# Environment files
.env
.env.local

# Hardhat files
cache/
artifacts/
typechain/
typechain-types/

# Coverage
coverage/
coverage.json

# Builds
build/
dist/
frontend/build/

# IDE
.vscode/
.idea/

# OS
.DS_Store
*.log

# Deployment files
deployments-*.json



=== FILE: ./package.json ===
{
  "name": "erc4337-multisig-mvp",
  "version": "1.0.0",
  "description": "ERC-4337 & ERC-6900 Smart Account MVP with Multi-Sig",
  "scripts": {
    "compile": "hardhat compile",
    "deploy": "hardhat run scripts/deploy.js",
    "deploy:local": "hardhat run scripts/deploy.js --network localhost",
    "deploy:sepolia": "hardhat run scripts/deploy.js --network sepolia",
    "test": "hardhat test",
    "node": "hardhat node"
  },
  "keywords": ["erc4337", "erc6900", "smart-account", "multisig"],
  "author": "",
  "license": "MIT",
  "devDependencies": {
    "@nomiclabs/hardhat-ethers": "^2.0.0",
    "@nomiclabs/hardhat-etherscan": "^3.0.0",
    "@nomiclabs/hardhat-waffle": "^2.0.0",
    "chai": "^4.2.0",
    "ethereum-waffle": "^3.0.0",
    "ethers": "^5.0.0",
    "hardhat": "^2.12.0"
  }
}



=== FILE: ./scripts/deploy.js.backup ===
// deploy.js - Deployment script for ERC-4337 & ERC-6900 contracts
const { ethers } = require("hardhat");
const fs = require('fs');

async function main() {
  console.log("ðŸš€ Deploying ERC-4337 & ERC-6900 Smart Account System...\n");

  // Get deployer
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with account:", deployer.address);
  console.log("Account balance:", ethers.utils.formatEther(await deployer.getBalance()), "ETH\n");

  // Deploy EntryPoint (or use existing one)
  console.log("1. Deploying EntryPoint...");
  let entryPoint;
  if (network.name === "localhost" || network.name === "hardhat") {
    const MockEntryPoint = await ethers.getContractFactory("MockEntryPoint");
    entryPoint = await MockEntryPoint.deploy();
    await entryPoint.deployed();
    console.log("   MockEntryPoint deployed to:", entryPoint.address);
  } else {
    // Use the official EntryPoint address for testnets/mainnet
    entryPoint = { address: "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789" };
    console.log("   Using official EntryPoint at:", entryPoint.address);
  }

  // Deploy MultiSigPlugin
  console.log("\n2. Deploying MultiSigPlugin...");
  const MultiSigPlugin = await ethers.getContractFactory("MultiSigPlugin");
  const multiSigPlugin = await MultiSigPlugin.deploy();
  await multiSigPlugin.deployed();
  console.log("   MultiSigPlugin deployed to:", multiSigPlugin.address);

  // Deploy SmartAccountFactory
  console.log("\n3. Deploying SmartAccountFactory...");
  const SmartAccountFactory = await ethers.getContractFactory("SmartAccountFactory");
  const factory = await SmartAccountFactory.deploy(entryPoint.address);
  await factory.deployed();
  console.log("   SmartAccountFactory deployed to:", factory.address);

  // Save deployment addresses
  const deploymentInfo = {
    network: network.name,
    chainId: network.config.chainId,
    deployer: deployer.address,
    contracts: {
      entryPoint: entryPoint.address,
      multiSigPlugin: multiSigPlugin.address,
      factory: factory.address
    },
    timestamp: new Date().toISOString()
  };

  // Write deployment info to file
  fs.writeFileSync(
    `deployments-${network.name}.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );

  // Update addresses.json
  const addressesPath = './scripts/addresses.json';
  let addresses = {};
  if (fs.existsSync(addressesPath)) {
    addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
  }
  
  addresses[network.name] = {
    entryPoint: entryPoint.address,
    factory: factory.address,
    multiSigPlugin: multiSigPlugin.address
  };
  
  fs.writeFileSync(addressesPath, JSON.stringify(addresses, null, 2));

  console.log("\nâœ… Deployment complete!");
  console.log("\nðŸ“„ Deployment info saved to:", `deployments-${network.name}.json`);
  
  // Verify contracts on Etherscan (if not on localhost)
  if (network.name !== "localhost" && network.name !== "hardhat") {
    console.log("\nðŸ” Verifying contracts on Etherscan...");
    
    await new Promise(resolve => setTimeout(resolve, 20000)); // Wait for Etherscan to index
    
    try {
      await hre.run("verify:verify", {
        address: multiSigPlugin.address,
        constructorArguments: [],
      });
      
      await hre.run("verify:verify", {
        address: factory.address,
        constructorArguments: [entryPoint.address],
      });
      
      console.log("âœ… Contracts verified!");
    } catch (error) {
      console.log("âš ï¸  Verification failed:", error.message);
    }
  }

  return deploymentInfo;
}

// Test script
async function testDeployment(deploymentInfo) {
  console.log("\nðŸ§ª Running deployment tests...\n");
  
  const [owner1, owner2, owner3] = await ethers.getSigners();
  
  // Get contract instances
  const factory = await ethers.getContractAt("SmartAccountFactory", deploymentInfo.contracts.factory);
  const multiSigPlugin = await ethers.getContractAt("MultiSigPlugin", deploymentInfo.contracts.multiSigPlugin);
  
  // Create a smart account
  console.log("1. Creating smart account...");
  const salt = 0;
  const tx = await factory.createAccount(owner1.address, salt);
  const receipt = await tx.wait();
  
  const accountAddress = await factory.getAddress(owner1.address, salt);
  console.log("   Smart account created at:", accountAddress);
  
  // Get account instance
  const account = await ethers.getContractAt("ModularSmartAccount", accountAddress);
  
  // Install multi-sig plugin
  console.log("\n2. Installing multi-sig plugin...");
  const owners = [owner1.address, owner2.address, owner3.address];
  const threshold = 2;
  
  const installData = ethers.utils.defaultAbiCoder.encode(
    ["address[]", "uint256"],
    [owners, threshold]
  );
  
  // Note: This would normally be done through a UserOperation
  const selector = "0x00000000"; // Custom selector for multi-sig
  await account.connect(owner1).installPlugin(selector, multiSigPlugin.address, installData);
  console.log("   Multi-sig plugin installed with", owners.length, "owners and threshold of", threshold);
  
  // Fund the account
  console.log("\n3. Funding account...");
  await owner1.sendTransaction({
    to: accountAddress,
    value: ethers.utils.parseEther("1.0")
  });
  const balance = await ethers.provider.getBalance(accountAddress);
  console.log("   Account balance:", ethers.utils.formatEther(balance), "ETH");
  
  console.log("\nâœ… All tests passed!");
}

// Run deployment and tests
main()
  .then(async (deploymentInfo) => {
    if (process.env.RUN_TESTS === "true") {
      await testDeployment(deploymentInfo);
    }
    process.exit(0);
  })
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });



=== FILE: ./scripts/addresses.json ===
{
  "localhost": {
    "entryPoint": "",
    "factory": "",
    "multiSigPlugin": ""
  },
  "sepolia": {
    "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "factory": "",
    "multiSigPlugin": ""
  },
  "holesky": {
    "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "factory": "",
    "multiSigPlugin": ""
  },
  "polygon_mumbai": {
    "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
    "factory": "",
    "multiSigPlugin": ""
  }
}


=== FILE: ./scripts/deploy.js ===
// deploy.js - Deployment script optimized for Sepolia with limited ETH
const { ethers } = require("hardhat");
const fs = require('fs');

async function main() {
  console.log("ðŸš€ Deploying ERC-4337 & ERC-6900 Smart Account System to", network.name, "...\n");

  // Get deployer
  const [deployer] = await ethers.getSigners();
  console.log("Deploying contracts with account:", deployer.address);
  const balance = await deployer.getBalance();
  console.log("Account balance:", ethers.utils.formatEther(balance), "ETH");
  
  // Check if we have enough ETH
  if (network.name === "sepolia" && balance.lt(ethers.utils.parseEther("0.05"))) {
    console.log("\nâš ï¸  Warning: Low balance for Sepolia deployment!");
    console.log("Recommended: At least 0.05 ETH for safe deployment");
    console.log("Current: ", ethers.utils.formatEther(balance), "ETH\n");
  }

  // Deploy EntryPoint (or use existing one)
  console.log("1. Checking EntryPoint...");
  let entryPoint;
  if (network.name === "localhost" || network.name === "hardhat") {
    console.log("   Deploying MockEntryPoint for local testing...");
    const MockEntryPoint = await ethers.getContractFactory("MockEntryPoint");
    entryPoint = await MockEntryPoint.deploy();
    await entryPoint.deployed();
    console.log("   âœ“ MockEntryPoint deployed to:", entryPoint.address);
  } else {
    // Use the official EntryPoint address for testnets/mainnet
    entryPoint = { address: "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789" };
    console.log("   âœ“ Using official EntryPoint at:", entryPoint.address);
    console.log("   (No deployment needed - saves gas!)");
  }

  // Deploy MultiSigPlugin with gas optimization
  console.log("\n2. Deploying MultiSigPlugin...");
  const MultiSigPlugin = await ethers.getContractFactory("MultiSigPlugin");
  
  // Estimate gas and add buffer
  const deployTx = MultiSigPlugin.getDeployTransaction();
  const estimatedGas = await deployer.estimateGas(deployTx);
  console.log("   Estimated gas:", estimatedGas.toString());
  
  // Deploy with optimized gas settings for Sepolia
  const multiSigPlugin = await MultiSigPlugin.deploy({
    gasLimit: estimatedGas.mul(110).div(100), // 10% buffer
    maxFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("20", "gwei") : undefined,
    maxPriorityFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("1.5", "gwei") : undefined
  });
  
  await multiSigPlugin.deployed();
  console.log("   âœ“ MultiSigPlugin deployed to:", multiSigPlugin.address);
  console.log("   Gas used:", (await multiSigPlugin.deployTransaction.wait()).gasUsed.toString());

  // Deploy SmartAccountFactory with gas optimization
  console.log("\n3. Deploying SmartAccountFactory...");
  const SmartAccountFactory = await ethers.getContractFactory("SmartAccountFactory");
  
  // Deploy with optimized gas settings
  const factory = await SmartAccountFactory.deploy(entryPoint.address, {
    gasLimit: 3000000, // Fixed reasonable limit
    maxFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("20", "gwei") : undefined,
    maxPriorityFeePerGas: network.name === "sepolia" ? ethers.utils.parseUnits("1.5", "gwei") : undefined
  });
  
  await factory.deployed();
  console.log("   âœ“ SmartAccountFactory deployed to:", factory.address);
  console.log("   Gas used:", (await factory.deployTransaction.wait()).gasUsed.toString());

  // Calculate total deployment cost
  if (network.name === "sepolia") {
    const deployerEndBalance = await deployer.getBalance();
    const totalCost = balance.sub(deployerEndBalance);
    console.log("\nðŸ’° Deployment Cost Summary:");
    console.log("   Total ETH spent:", ethers.utils.formatEther(totalCost));
    console.log("   Remaining balance:", ethers.utils.formatEther(deployerEndBalance), "ETH");
  }

  // Save deployment addresses
  const deploymentInfo = {
    network: network.name,
    chainId: network.config.chainId,
    deployer: deployer.address,
    contracts: {
      entryPoint: entryPoint.address,
      multiSigPlugin: multiSigPlugin.address,
      factory: factory.address
    },
    timestamp: new Date().toISOString(),
    deploymentCost: network.name === "sepolia" ? {
      multiSigPluginGas: (await multiSigPlugin.deployTransaction.wait()).gasUsed.toString(),
      factoryGas: (await factory.deployTransaction.wait()).gasUsed.toString()
    } : undefined
  };

  // Write deployment info to file
  fs.writeFileSync(
    `deployments-${network.name}.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );

  // Update addresses.json
  const addressesPath = './scripts/addresses.json';
  let addresses = {};
  if (fs.existsSync(addressesPath)) {
    addresses = JSON.parse(fs.readFileSync(addressesPath, 'utf8'));
  }
  
  addresses[network.name] = {
    entryPoint: entryPoint.address,
    factory: factory.address,
    multiSigPlugin: multiSigPlugin.address
  };
  
  fs.writeFileSync(addressesPath, JSON.stringify(addresses, null, 2));

  console.log("\nâœ… Deployment complete!");
  console.log("\nðŸ“„ Deployment info saved to:", `deployments-${network.name}.json`);
  console.log("\nðŸ”— Contract Addresses:");
  console.log("   EntryPoint:", entryPoint.address);
  console.log("   MultiSigPlugin:", multiSigPlugin.address);
  console.log("   SmartAccountFactory:", factory.address);
  
  // Sepolia specific instructions
  if (network.name === "sepolia") {
    console.log("\nðŸ“ Next Steps for Sepolia:");
    console.log("   1. Verify contracts on Etherscan:");
    console.log("      npx hardhat run scripts/verify.js --network sepolia");
    console.log("   2. Update frontend with deployed addresses");
    console.log("   3. You can interact with contracts at:");
    console.log("      https://sepolia.etherscan.io/address/" + multiSigPlugin.address);
    console.log("      https://sepolia.etherscan.io/address/" + factory.address);
  }
  
  // Skip automatic verification for Sepolia to save time
  if (network.name === "sepolia") {
    console.log("\nðŸ“Œ Note: Skipping automatic verification to complete deployment faster.");
    console.log("   Run verification manually when ready.");
  } else if (network.name !== "localhost" && network.name !== "hardhat") {
    console.log("\nðŸ” Waiting before verification...");
    await new Promise(resolve => setTimeout(resolve, 20000));
    
    try {
      await hre.run("verify:verify", {
        address: multiSigPlugin.address,
        constructorArguments: [],
      });
      
      await hre.run("verify:verify", {
        address: factory.address,
        constructorArguments: [entryPoint.address],
      });
      
      console.log("âœ… Contracts verified!");
    } catch (error) {
      console.log("âš ï¸  Verification failed:", error.message);
    }
  }

  return deploymentInfo;
}

// Minimal test script for Sepolia (to save gas)
async function minimalTest(deploymentInfo) {
  console.log("\nðŸ§ª Running minimal deployment test...\n");
  
  const [deployer] = await ethers.getSigners();
  
  // Just verify contracts are deployed
  console.log("1. Checking MultiSigPlugin...");
  const multiSigCode = await ethers.provider.getCode(deploymentInfo.contracts.multiSigPlugin);
  console.log("   âœ“ MultiSigPlugin deployed:", multiSigCode.length > 2);
  
  console.log("\n2. Checking SmartAccountFactory...");
  const factoryCode = await ethers.provider.getCode(deploymentInfo.contracts.factory);
  console.log("   âœ“ SmartAccountFactory deployed:", factoryCode.length > 2);
  
  console.log("\nâœ… Basic deployment verification passed!");
  console.log("\nðŸ’¡ Tip: Create and test smart accounts using the frontend to save ETH");
}

// Run deployment
main()
  .then(async (deploymentInfo) => {
    // Only run tests on localhost
    if (network.name === "localhost" && process.env.RUN_TESTS === "true") {
      const { testDeployment } = require('./test-deployment');
      await testDeployment(deploymentInfo);
    } else if (network.name === "sepolia") {
      await minimalTest(deploymentInfo);
    }
    process.exit(0);
  })
  .catch((error) => {
    console.error("\nâŒ Deployment failed:", error.message);
    console.error(error);
    process.exit(1);
  });



=== FILE: ./scripts/verify.js ===
// Contract verification script
const hre = require("hardhat");

async function main() {
  console.log("[>] Verifying contracts on Etherscan...");
  
  // Load deployment addresses
  const addresses = require("./addresses.json")[hre.network.name];
  
  if (addresses.multiSigPlugin) {
    await hre.run("verify:verify", {
      address: addresses.multiSigPlugin,
      constructorArguments: [],
    });
  }
  
  if (addresses.factory) {
    await hre.run("verify:verify", {
      address: addresses.factory,
      constructorArguments: [addresses.entryPoint],
    });
  }
  
  console.log("[+] Verification complete!");
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});



=== FILE: ./scripts/estimate-gas.js ===
// estimate-gas.js - Estimate deployment costs
const { ethers } = require("hardhat");

async function main() {
  console.log("ðŸ’° Estimating deployment costs for", network.name, "...\n");
  
  const [deployer] = await ethers.getSigners();
  
  // Get current gas prices
  const gasPrice = await deployer.getGasPrice();
  console.log("Current gas price:", ethers.utils.formatUnits(gasPrice, "gwei"), "gwei");
  
  // Estimate MockEntryPoint (only for localhost)
  if (network.name === "localhost") {
    const MockEntryPoint = await ethers.getContractFactory("MockEntryPoint");
    const mockGas = await deployer.estimateGas(MockEntryPoint.getDeployTransaction());
    console.log("\nMockEntryPoint:");
    console.log("  Gas:", mockGas.toString());
    console.log("  Cost:", ethers.utils.formatEther(mockGas.mul(gasPrice)), "ETH");
  }
  
  // Estimate MultiSigPlugin
  const MultiSigPlugin = await ethers.getContractFactory("MultiSigPlugin");
  const multiSigGas = await deployer.estimateGas(MultiSigPlugin.getDeployTransaction());
  console.log("\nMultiSigPlugin:");
  console.log("  Gas:", multiSigGas.toString());
  console.log("  Cost:", ethers.utils.formatEther(multiSigGas.mul(gasPrice)), "ETH");
  
  // Estimate SmartAccountFactory
  const SmartAccountFactory = await ethers.getContractFactory("SmartAccountFactory");
  const factoryGas = await deployer.estimateGas(
    SmartAccountFactory.getDeployTransaction("0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789")
  );
  console.log("\nSmartAccountFactory:");
  console.log("  Gas:", factoryGas.toString());
  console.log("  Cost:", ethers.utils.formatEther(factoryGas.mul(gasPrice)), "ETH");
  
  // Total
  const totalGas = multiSigGas.add(factoryGas);
  const totalCost = totalGas.mul(gasPrice);
  console.log("\nðŸ“Š Total Deployment Cost:");
  console.log("  Total Gas:", totalGas.toString());
  console.log("  Total Cost:", ethers.utils.formatEther(totalCost), "ETH");
  
  // With 50% buffer
  const bufferedCost = totalCost.mul(150).div(100);
  console.log("  With 50% buffer:", ethers.utils.formatEther(bufferedCost), "ETH");
  
  if (network.name === "sepolia") {
    console.log("\nðŸ’¡ Sepolia Deployment Tips:");
    console.log("  - Current balance needed: ~", ethers.utils.formatEther(bufferedCost), "ETH");
    console.log("  - Your 0.1 ETH should be sufficient!");
    console.log("  - Use the deploy-sepolia.sh script for easy deployment");
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });



=== FILE: ./scripts/deploy-sepolia.sh ===
#!/bin/bash

echo "======================================"
echo " Deploying to Sepolia Testnet"
echo "======================================"
echo ""

# Check if .env exists
if [ ! -f .env ]; then
    echo "âŒ Error: .env file not found!"
    echo "Please copy .env.example to .env and add your keys"
    exit 1
fi

# Load environment variables
source .env

# Check if PRIVATE_KEY is set
if [ -z "$PRIVATE_KEY" ]; then
    echo "âŒ Error: PRIVATE_KEY not set in .env!"
    exit 1
fi

# Check if SEPOLIA_RPC_URL is set
if [ -z "$SEPOLIA_RPC_URL" ]; then
    echo "âŒ Error: SEPOLIA_RPC_URL not set in .env!"
    exit 1
fi

echo "âœ“ Environment configured"
echo ""

# Compile contracts
echo "ðŸ“¦ Compiling contracts..."
npx hardhat compile

if [ $? -ne 0 ]; then
    echo "âŒ Compilation failed!"
    exit 1
fi

echo "âœ“ Contracts compiled"
echo ""

# Deploy to Sepolia
echo "ðŸš€ Deploying to Sepolia..."
echo "This will use approximately 0.02-0.05 ETH"
echo ""

npx hardhat run scripts/deploy.js --network sepolia

if [ $? -eq 0 ]; then
    echo ""
    echo "âœ… Deployment successful!"
    echo ""
    echo "ðŸ“‹ Check deployments-sepolia.json for contract addresses"
    echo ""
    echo "Next steps:"
    echo "1. Verify contracts: npx hardhat run scripts/verify.js --network sepolia"
    echo "2. Update frontend with the deployed addresses"
    echo "3. Test using the React GUI"
else
    echo ""
    echo "âŒ Deployment failed!"
    echo "Check your ETH balance and try again"
fi



=== FILE: ./.env.example ===
# RPC URLs
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_INFURA_KEY
HOLESKY_RPC_URL=https://holesky.infura.io/v3/YOUR_INFURA_KEY
POLYGON_MUMBAI_RPC_URL=https://polygon-mumbai.infura.io/v3/YOUR_INFURA_KEY
ARBITRUM_SEPOLIA_RPC_URL=https://arbitrum-sepolia.infura.io/v3/YOUR_INFURA_KEY

# Private key (without 0x prefix)
PRIVATE_KEY=your_private_key_here

# Etherscan API key for verification
ETHERSCAN_API_KEY=your_etherscan_api_key
POLYGONSCAN_API_KEY=your_polygonscan_api_key
ARBISCAN_API_KEY=your_arbiscan_api_key



